"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * AddressesApi - axios parameter creator
 * @export
 */
const AddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
         * @summary Create a deposit address
         * @param {BusinessGenerateAddressRequest} [businessGenerateAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessDepositAddress: (businessGenerateAddressRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/wallets/addresses/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(businessGenerateAddressRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
         * @summary Create a recipient address
         * @param {BusinessRecipientAddressCreationRequest} [businessRecipientAddressCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessRecipientAddress: (businessRecipientAddressCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/wallets/addresses/recipient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(businessRecipientAddressCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary List all deposit addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDepositAddress: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/wallets/addresses/deposit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response.
         * @summary List all recipient addresses
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessRecipientAddresses: (from, to, pageBefore, pageAfter, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/wallets/addresses/recipient`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (from !== undefined) {
                localVarQueryParameter["from"] =
                    from instanceof Date ? from.toISOString() : from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] =
                    to instanceof Date ? to.toISOString() : to;
            }
            if (pageBefore !== undefined) {
                localVarQueryParameter["pageBefore"] = pageBefore;
            }
            if (pageAfter !== undefined) {
                localVarQueryParameter["pageAfter"] = pageAfter;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["pageSize"] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;
/**
 * AddressesApi - functional programming interface
 * @export
 */
const AddressesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AddressesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
         * @summary Create a deposit address
         * @param {BusinessGenerateAddressRequest} [businessGenerateAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessDepositAddress(businessGenerateAddressRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBusinessDepositAddress(businessGenerateAddressRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
         * @summary Create a recipient address
         * @param {BusinessRecipientAddressCreationRequest} [businessRecipientAddressCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessRecipientAddress(businessRecipientAddressCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBusinessRecipientAddress(businessRecipientAddressCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List all deposit addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDepositAddress(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBusinessDepositAddress(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response.
         * @summary List all recipient addresses
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBusinessRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.AddressesApiFp = AddressesApiFp;
/**
 * AddressesApi - factory interface
 * @export
 */
const AddressesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AddressesApiFp)(configuration);
    return {
        /**
         * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
         * @summary Create a deposit address
         * @param {BusinessGenerateAddressRequest} [businessGenerateAddressRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessDepositAddress(businessGenerateAddressRequest, options) {
            return localVarFp
                .createBusinessDepositAddress(businessGenerateAddressRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
         * @summary Create a recipient address
         * @param {BusinessRecipientAddressCreationRequest} [businessRecipientAddressCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessRecipientAddress(businessRecipientAddressCreationRequest, options) {
            return localVarFp
                .createBusinessRecipientAddress(businessRecipientAddressCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all deposit addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessDepositAddress(options) {
            return localVarFp
                .getBusinessDepositAddress(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response.
         * @summary List all recipient addresses
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options) {
            return localVarFp
                .listBusinessRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.AddressesApiFactory = AddressesApiFactory;
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
class AddressesApi extends base_1.BaseAPI {
    /**
     * Generates a new blockchain address for a wallet for a given currency/chain pair. Circle may reuse addresses on blockchains that support reuse. For example, if you\'re requesting two addresses for depositing USD and ETH, both on Ethereum, you may see the same Ethereum address returned. Depositing cryptocurrency to a generated address will credit the associated wallet with the value of the deposit. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
     * @summary Create a deposit address
     * @param {BusinessGenerateAddressRequest} [businessGenerateAddressRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    createBusinessDepositAddress(businessGenerateAddressRequest, options) {
        return (0, exports.AddressesApiFp)(this.configuration)
            .createBusinessDepositAddress(businessGenerateAddressRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Stores an external blockchain address. Once added, the recipient address must be verified to ensure that you know and trust each new address. Note: Circle Mint Singapore customers must verify all transfer recipients using the UI in the Circle Console, as transfers from unverified addresses will be held in `pending` status.
     * @summary Create a recipient address
     * @param {BusinessRecipientAddressCreationRequest} [businessRecipientAddressCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    createBusinessRecipientAddress(businessRecipientAddressCreationRequest, options) {
        return (0, exports.AddressesApiFp)(this.configuration)
            .createBusinessRecipientAddress(businessRecipientAddressCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all deposit addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    getBusinessDepositAddress(options) {
        return (0, exports.AddressesApiFp)(this.configuration)
            .getBusinessDepositAddress(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of recipient addresses that have each been verified and are eligible for transfers. Any recipient addresses pending verification are not included in the response.
     * @summary List all recipient addresses
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    listBusinessRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options) {
        return (0, exports.AddressesApiFp)(this.configuration)
            .listBusinessRecipientAddresses(from, to, pageBefore, pageAfter, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.AddressesApi = AddressesApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkcmVzc2VzLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9nZW5lcmF0ZWQvYXBpcy9hZGRyZXNzZXMtYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCOzs7O0dBSUc7Ozs7Ozs7Ozs7Ozs7OztBQUVILGtEQUllO0FBRWYseURBQXlEO0FBQ3pELGFBQWE7QUFDYixzQ0FRbUI7QUFDbkIsYUFBYTtBQUNiLGtDQU1pQjtBQWlCakI7OztHQUdHO0FBQ0ksTUFBTSw2QkFBNkIsR0FBRyxVQUMzQyxhQUE2QjtJQUU3QixPQUFPO1FBQ0w7Ozs7OztXQU1HO1FBQ0gsNEJBQTRCLEVBQUUsQ0FDNUIsOEJBQStELEVBQy9ELFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLCtDQUErQyxDQUFDO1lBQ3JFLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsTUFBTSxJQUNYLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDO1lBRTdELElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJQUFJLHNCQUFzQixHQUN4QixXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLHNCQUFzQixDQUFDLE9BQU8saURBQ3pCLHVCQUF1QixHQUN2QixzQkFBc0IsR0FDdEIsT0FBTyxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztZQUNGLHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFBLDhCQUFxQixFQUNqRCw4QkFBOEIsRUFDOUIsc0JBQXNCLEVBQ3RCLGFBQWEsQ0FDZCxDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBQ0Q7Ozs7OztXQU1HO1FBQ0gsOEJBQThCLEVBQUUsQ0FDOUIsdUNBQWlGLEVBQ2pGLFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLGlEQUFpRCxDQUFDO1lBQ3ZFLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsTUFBTSxJQUNYLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDO1lBRTdELElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJQUFJLHNCQUFzQixHQUN4QixXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLHNCQUFzQixDQUFDLE9BQU8saURBQ3pCLHVCQUF1QixHQUN2QixzQkFBc0IsR0FDdEIsT0FBTyxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztZQUNGLHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFBLDhCQUFxQixFQUNqRCx1Q0FBdUMsRUFDdkMsc0JBQXNCLEVBQ3RCLGFBQWEsQ0FDZCxDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBQ0Q7Ozs7O1dBS0c7UUFDSCx5QkFBeUIsRUFBRSxDQUN6QixVQUE4QixFQUFFLEVBQ1YsRUFBRTtZQUN4QixNQUFNLFlBQVksR0FBRywrQ0FBK0MsQ0FBQztZQUNyRSxvRkFBb0Y7WUFDcEYsTUFBTSxjQUFjLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxFQUFFLHVCQUFjLENBQUMsQ0FBQztZQUM3RCxJQUFJLFdBQVcsQ0FBQztZQUNoQixJQUFJLGFBQWEsRUFBRTtnQkFDakIsV0FBVyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUM7YUFDekM7WUFFRCxNQUFNLHNCQUFzQixpQ0FDMUIsTUFBTSxFQUFFLEtBQUssSUFDVixXQUFXLEdBQ1gsT0FBTyxDQUNYLENBQUM7WUFDRixNQUFNLHVCQUF1QixHQUFHLEVBQVMsQ0FBQztZQUMxQyxNQUFNLHNCQUFzQixHQUFHLEVBQVMsQ0FBQztZQUV6QyxxQ0FBcUM7WUFDckMsc0NBQXNDO1lBQ3RDLE1BQU0sSUFBQSw4QkFBcUIsRUFBQyx1QkFBdUIsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUVwRSxJQUFBLHdCQUFlLEVBQUMsY0FBYyxFQUFFLHNCQUFzQixDQUFDLENBQUM7WUFDeEQsSUFBSSxzQkFBc0IsR0FDeEIsV0FBVyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNoRSxzQkFBc0IsQ0FBQyxPQUFPLGlEQUN6Qix1QkFBdUIsR0FDdkIsc0JBQXNCLEdBQ3RCLE9BQU8sQ0FBQyxPQUFPLENBQ25CLENBQUM7WUFFRixPQUFPO2dCQUNMLEdBQUcsRUFBRSxJQUFBLHFCQUFZLEVBQUMsY0FBYyxDQUFDO2dCQUNqQyxPQUFPLEVBQUUsc0JBQXNCO2FBQ2hDLENBQUM7UUFDSixDQUFDLENBQUE7UUFDRDs7Ozs7Ozs7OztXQVVHO1FBQ0gsOEJBQThCLEVBQUUsQ0FDOUIsSUFBYSxFQUNiLEVBQVcsRUFDWCxVQUFtQixFQUNuQixTQUFrQixFQUNsQixRQUFpQixFQUNqQixVQUE4QixFQUFFLEVBQ1YsRUFBRTtZQUN4QixNQUFNLFlBQVksR0FBRyxpREFBaUQsQ0FBQztZQUN2RSxvRkFBb0Y7WUFDcEYsTUFBTSxjQUFjLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxFQUFFLHVCQUFjLENBQUMsQ0FBQztZQUM3RCxJQUFJLFdBQVcsQ0FBQztZQUNoQixJQUFJLGFBQWEsRUFBRTtnQkFDakIsV0FBVyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUM7YUFDekM7WUFFRCxNQUFNLHNCQUFzQixpQ0FDMUIsTUFBTSxFQUFFLEtBQUssSUFDVixXQUFXLEdBQ1gsT0FBTyxDQUNYLENBQUM7WUFDRixNQUFNLHVCQUF1QixHQUFHLEVBQVMsQ0FBQztZQUMxQyxNQUFNLHNCQUFzQixHQUFHLEVBQVMsQ0FBQztZQUV6QyxxQ0FBcUM7WUFDckMsc0NBQXNDO1lBQ3RDLE1BQU0sSUFBQSw4QkFBcUIsRUFBQyx1QkFBdUIsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUVwRSxJQUFJLElBQUksS0FBSyxTQUFTLEVBQUU7Z0JBQ3RCLHNCQUFzQixDQUFDLE1BQU0sQ0FBQztvQkFDM0IsSUFBWSxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUUsSUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7YUFDdEU7WUFFRCxJQUFJLEVBQUUsS0FBSyxTQUFTLEVBQUU7Z0JBQ3BCLHNCQUFzQixDQUFDLElBQUksQ0FBQztvQkFDekIsRUFBVSxZQUFZLElBQUksQ0FBQyxDQUFDLENBQUUsRUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7YUFDaEU7WUFFRCxJQUFJLFVBQVUsS0FBSyxTQUFTLEVBQUU7Z0JBQzVCLHNCQUFzQixDQUFDLFlBQVksQ0FBQyxHQUFHLFVBQVUsQ0FBQzthQUNuRDtZQUVELElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtnQkFDM0Isc0JBQXNCLENBQUMsV0FBVyxDQUFDLEdBQUcsU0FBUyxDQUFDO2FBQ2pEO1lBRUQsSUFBSSxRQUFRLEtBQUssU0FBUyxFQUFFO2dCQUMxQixzQkFBc0IsQ0FBQyxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUM7YUFDL0M7WUFFRCxJQUFBLHdCQUFlLEVBQUMsY0FBYyxFQUFFLHNCQUFzQixDQUFDLENBQUM7WUFDeEQsSUFBSSxzQkFBc0IsR0FDeEIsV0FBVyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNoRSxzQkFBc0IsQ0FBQyxPQUFPLGlEQUN6Qix1QkFBdUIsR0FDdkIsc0JBQXNCLEdBQ3RCLE9BQU8sQ0FBQyxPQUFPLENBQ25CLENBQUM7WUFFRixPQUFPO2dCQUNMLEdBQUcsRUFBRSxJQUFBLHFCQUFZLEVBQUMsY0FBYyxDQUFDO2dCQUNqQyxPQUFPLEVBQUUsc0JBQXNCO2FBQ2hDLENBQUM7UUFDSixDQUFDLENBQUE7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBbk9XLFFBQUEsNkJBQTZCLGlDQW1PeEM7QUFFRjs7O0dBR0c7QUFDSSxNQUFNLGNBQWMsR0FBRyxVQUFVLGFBQTZCO0lBQ25FLE1BQU0seUJBQXlCLEdBQzdCLElBQUEscUNBQTZCLEVBQUMsYUFBYSxDQUFDLENBQUM7SUFDL0MsT0FBTztRQUNMOzs7Ozs7V0FNRztRQUNHLDRCQUE0QixDQUNoQyw4QkFBK0QsRUFDL0QsT0FBNEI7O2dCQU81QixNQUFNLGlCQUFpQixHQUNyQixNQUFNLHlCQUF5QixDQUFDLDRCQUE0QixDQUMxRCw4QkFBOEIsRUFDOUIsT0FBTyxDQUNSLENBQUM7Z0JBQ0osT0FBTyxJQUFBLDhCQUFxQixFQUMxQixpQkFBaUIsRUFDakIsZUFBVyxFQUNYLGdCQUFTLEVBQ1QsYUFBYSxDQUNkLENBQUM7WUFDSixDQUFDO1NBQUE7UUFDRDs7Ozs7O1dBTUc7UUFDRyw4QkFBOEIsQ0FDbEMsdUNBQWlGLEVBQ2pGLE9BQTRCOztnQkFPNUIsTUFBTSxpQkFBaUIsR0FDckIsTUFBTSx5QkFBeUIsQ0FBQyw4QkFBOEIsQ0FDNUQsdUNBQXVDLEVBQ3ZDLE9BQU8sQ0FDUixDQUFDO2dCQUNKLE9BQU8sSUFBQSw4QkFBcUIsRUFDMUIsaUJBQWlCLEVBQ2pCLGVBQVcsRUFDWCxnQkFBUyxFQUNULGFBQWEsQ0FDZCxDQUFDO1lBQ0osQ0FBQztTQUFBO1FBQ0Q7Ozs7O1dBS0c7UUFDRyx5QkFBeUIsQ0FDN0IsT0FBNEI7O2dCQU81QixNQUFNLGlCQUFpQixHQUNyQixNQUFNLHlCQUF5QixDQUFDLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUNyRSxPQUFPLElBQUEsOEJBQXFCLEVBQzFCLGlCQUFpQixFQUNqQixlQUFXLEVBQ1gsZ0JBQVMsRUFDVCxhQUFhLENBQ2QsQ0FBQztZQUNKLENBQUM7U0FBQTtRQUNEOzs7Ozs7Ozs7O1dBVUc7UUFDRyw4QkFBOEIsQ0FDbEMsSUFBYSxFQUNiLEVBQVcsRUFDWCxVQUFtQixFQUNuQixTQUFrQixFQUNsQixRQUFpQixFQUNqQixPQUE0Qjs7Z0JBTzVCLE1BQU0saUJBQWlCLEdBQ3JCLE1BQU0seUJBQXlCLENBQUMsOEJBQThCLENBQzVELElBQUksRUFDSixFQUFFLEVBQ0YsVUFBVSxFQUNWLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxDQUNSLENBQUM7Z0JBQ0osT0FBTyxJQUFBLDhCQUFxQixFQUMxQixpQkFBaUIsRUFDakIsZUFBVyxFQUNYLGdCQUFTLEVBQ1QsYUFBYSxDQUNkLENBQUM7WUFDSixDQUFDO1NBQUE7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBNUhXLFFBQUEsY0FBYyxrQkE0SHpCO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSxtQkFBbUIsR0FBRyxVQUNqQyxhQUE2QixFQUM3QixRQUFpQixFQUNqQixLQUFxQjtJQUVyQixNQUFNLFVBQVUsR0FBRyxJQUFBLHNCQUFjLEVBQUMsYUFBYSxDQUFDLENBQUM7SUFDakQsT0FBTztRQUNMOzs7Ozs7V0FNRztRQUNILDRCQUE0QixDQUMxQiw4QkFBK0QsRUFDL0QsT0FBYTtZQUViLE9BQU8sVUFBVTtpQkFDZCw0QkFBNEIsQ0FBQyw4QkFBOEIsRUFBRSxPQUFPLENBQUM7aUJBQ3JFLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7UUFDRDs7Ozs7O1dBTUc7UUFDSCw4QkFBOEIsQ0FDNUIsdUNBQWlGLEVBQ2pGLE9BQWE7WUFFYixPQUFPLFVBQVU7aUJBQ2QsOEJBQThCLENBQzdCLHVDQUF1QyxFQUN2QyxPQUFPLENBQ1I7aUJBQ0EsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakQsQ0FBQztRQUNEOzs7OztXQUtHO1FBQ0gseUJBQXlCLENBQ3ZCLE9BQWE7WUFFYixPQUFPLFVBQVU7aUJBQ2QseUJBQXlCLENBQUMsT0FBTyxDQUFDO2lCQUNsQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDO1FBQ0Q7Ozs7Ozs7Ozs7V0FVRztRQUNILDhCQUE4QixDQUM1QixJQUFhLEVBQ2IsRUFBVyxFQUNYLFVBQW1CLEVBQ25CLFNBQWtCLEVBQ2xCLFFBQWlCLEVBQ2pCLE9BQWE7WUFFYixPQUFPLFVBQVU7aUJBQ2QsOEJBQThCLENBQzdCLElBQUksRUFDSixFQUFFLEVBQ0YsVUFBVSxFQUNWLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxDQUNSO2lCQUNBLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBcEZXLFFBQUEsbUJBQW1CLHVCQW9GOUI7QUFFRjs7Ozs7R0FLRztBQUNILE1BQWEsWUFBYSxTQUFRLGNBQU87SUFDdkM7Ozs7Ozs7T0FPRztJQUNJLDRCQUE0QixDQUNqQyw4QkFBK0QsRUFDL0QsT0FBNEI7UUFFNUIsT0FBTyxJQUFBLHNCQUFjLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUN0Qyw0QkFBNEIsQ0FBQyw4QkFBOEIsRUFBRSxPQUFPLENBQUM7YUFDckUsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLDhCQUE4QixDQUNuQyx1Q0FBaUYsRUFDakYsT0FBNEI7UUFFNUIsT0FBTyxJQUFBLHNCQUFjLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUN0Qyw4QkFBOEIsQ0FDN0IsdUNBQXVDLEVBQ3ZDLE9BQU8sQ0FDUjthQUNBLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLHlCQUF5QixDQUFDLE9BQTRCO1FBQzNELE9BQU8sSUFBQSxzQkFBYyxFQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7YUFDdEMseUJBQXlCLENBQUMsT0FBTyxDQUFDO2FBQ2xDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7Ozs7OztPQVdHO0lBQ0ksOEJBQThCLENBQ25DLElBQWEsRUFDYixFQUFXLEVBQ1gsVUFBbUIsRUFDbkIsU0FBa0IsRUFDbEIsUUFBaUIsRUFDakIsT0FBNEI7UUFFNUIsT0FBTyxJQUFBLHNCQUFjLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUN0Qyw4QkFBOEIsQ0FDN0IsSUFBSSxFQUNKLEVBQUUsRUFDRixVQUFVLEVBQ1YsU0FBUyxFQUNULFFBQVEsRUFDUixPQUFPLENBQ1I7YUFDQSxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7Q0FDRjtBQWxGRCxvQ0FrRkMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5cbmltcG9ydCBnbG9iYWxBeGlvcywge1xuICBBeGlvc1Byb21pc2UsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZ1xufSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29uZmlndXJhdGlvblwiO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBEVU1NWV9CQVNFX1VSTCxcbiAgYXNzZXJ0UGFyYW1FeGlzdHMsXG4gIHNldEJlYXJlckF1dGhUb09iamVjdCxcbiAgc2V0U2VhcmNoUGFyYW1zLFxuICBzZXJpYWxpemVEYXRhSWZOZWVkZWQsXG4gIHRvUGF0aFN0cmluZyxcbiAgY3JlYXRlUmVxdWVzdEZ1bmN0aW9uXG59IGZyb20gXCIuLi9jb21tb25cIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7XG4gIEJBU0VfUEFUSCxcbiAgQ09MTEVDVElPTl9GT1JNQVRTLFxuICBSZXF1ZXN0QXJncyxcbiAgQmFzZUFQSSxcbiAgUmVxdWlyZWRFcnJvclxufSBmcm9tIFwiLi4vYmFzZVwiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgQmFkUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJ1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENyZWF0ZUJ1c2luZXNzRGVwb3NpdEFkZHJlc3NSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc1Jlc3BvbnNlIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgR2V0QnVzaW5lc3NEZXBvc2l0QWRkcmVzc1Jlc3BvbnNlIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgTGlzdEJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc2VzUmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBOb3RBdXRob3JpemVkIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgQWRkcmVzc2VzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uXG4pIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgYmxvY2tjaGFpbiBhZGRyZXNzIGZvciBhIHdhbGxldCBmb3IgYSBnaXZlbiBjdXJyZW5jeS9jaGFpbiBwYWlyLiBDaXJjbGUgbWF5IHJldXNlIGFkZHJlc3NlcyBvbiBibG9ja2NoYWlucyB0aGF0IHN1cHBvcnQgcmV1c2UuIEZvciBleGFtcGxlLCBpZiB5b3VcXCdyZSByZXF1ZXN0aW5nIHR3byBhZGRyZXNzZXMgZm9yIGRlcG9zaXRpbmcgVVNEIGFuZCBFVEgsIGJvdGggb24gRXRoZXJldW0sIHlvdSBtYXkgc2VlIHRoZSBzYW1lIEV0aGVyZXVtIGFkZHJlc3MgcmV0dXJuZWQuIERlcG9zaXRpbmcgY3J5cHRvY3VycmVuY3kgdG8gYSBnZW5lcmF0ZWQgYWRkcmVzcyB3aWxsIGNyZWRpdCB0aGUgYXNzb2NpYXRlZCB3YWxsZXQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGRlcG9zaXQuIE5vdGU6IENpcmNsZSBNaW50IFNpbmdhcG9yZSBjdXN0b21lcnMgbXVzdCB2ZXJpZnkgYWxsIHRyYW5zZmVyIHJlY2lwaWVudHMgdXNpbmcgdGhlIFVJIGluIHRoZSBDaXJjbGUgQ29uc29sZSwgYXMgdHJhbnNmZXJzIGZyb20gdW52ZXJpZmllZCBhZGRyZXNzZXMgd2lsbCBiZSBoZWxkIGluIGBwZW5kaW5nYCBzdGF0dXMuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgZGVwb3NpdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtCdXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3R9IFtidXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZUJ1c2luZXNzRGVwb3NpdEFkZHJlc3M6IGFzeW5jIChcbiAgICAgIGJ1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdD86IEJ1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9idXNpbmVzc0FjY291bnQvd2FsbGV0cy9hZGRyZXNzZXMvZGVwb3NpdGA7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlcltcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gc2VyaWFsaXplRGF0YUlmTmVlZGVkKFxuICAgICAgICBidXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3QsXG4gICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBhbiBleHRlcm5hbCBibG9ja2NoYWluIGFkZHJlc3MuIE9uY2UgYWRkZWQsIHRoZSByZWNpcGllbnQgYWRkcmVzcyBtdXN0IGJlIHZlcmlmaWVkIHRvIGVuc3VyZSB0aGF0IHlvdSBrbm93IGFuZCB0cnVzdCBlYWNoIG5ldyBhZGRyZXNzLiBOb3RlOiBDaXJjbGUgTWludCBTaW5nYXBvcmUgY3VzdG9tZXJzIG11c3QgdmVyaWZ5IGFsbCB0cmFuc2ZlciByZWNpcGllbnRzIHVzaW5nIHRoZSBVSSBpbiB0aGUgQ2lyY2xlIENvbnNvbGUsIGFzIHRyYW5zZmVycyBmcm9tIHVudmVyaWZpZWQgYWRkcmVzc2VzIHdpbGwgYmUgaGVsZCBpbiBgcGVuZGluZ2Agc3RhdHVzLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHJlY2lwaWVudCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3NDcmVhdGlvblJlcXVlc3R9IFtidXNpbmVzc1JlY2lwaWVudEFkZHJlc3NDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzczogYXN5bmMgKFxuICAgICAgYnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2J1c2luZXNzQWNjb3VudC93YWxsZXRzL2FkZHJlc3Nlcy9yZWNpcGllbnRgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG4gICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge30gYXMgYW55O1xuXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWFyZXJBdXRoIHJlcXVpcmVkXG4gICAgICAvLyBodHRwIGJlYXJlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFxuICAgICAgYXdhaXQgc2V0QmVhcmVyQXV0aFRvT2JqZWN0KGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9IHNlcmlhbGl6ZURhdGFJZk5lZWRlZChcbiAgICAgICAgYnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIGRlcG9zaXQgYWRkcmVzc2VzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGdldEJ1c2luZXNzRGVwb3NpdEFkZHJlc3M6IGFzeW5jIChcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9idXNpbmVzc0FjY291bnQvd2FsbGV0cy9hZGRyZXNzZXMvZGVwb3NpdGA7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgdGhhdCBoYXZlIGVhY2ggYmVlbiB2ZXJpZmllZCBhbmQgYXJlIGVsaWdpYmxlIGZvciB0cmFuc2ZlcnMuIEFueSByZWNpcGllbnQgYWRkcmVzc2VzIHBlbmRpbmcgdmVyaWZpY2F0aW9uIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHJlY2lwaWVudCBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUJlZm9yZV0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGVuZCBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYmVmb3JlIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VBZnRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgbGlzdEJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc2VzOiBhc3luYyAoXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvYnVzaW5lc3NBY2NvdW50L3dhbGxldHMvYWRkcmVzc2VzL3JlY2lwaWVudGA7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGlmIChmcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcImZyb21cIl0gPVxuICAgICAgICAgIChmcm9tIGFzIGFueSkgaW5zdGFuY2VvZiBEYXRlID8gKGZyb20gYXMgYW55KS50b0lTT1N0cmluZygpIDogZnJvbTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInRvXCJdID1cbiAgICAgICAgICAodG8gYXMgYW55KSBpbnN0YW5jZW9mIERhdGUgPyAodG8gYXMgYW55KS50b0lTT1N0cmluZygpIDogdG87XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlQmVmb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInBhZ2VCZWZvcmVcIl0gPSBwYWdlQmVmb3JlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZUFmdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInBhZ2VBZnRlclwiXSA9IHBhZ2VBZnRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInBhZ2VTaXplXCJdID0gcGFnZVNpemU7XG4gICAgICB9XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEFkZHJlc3Nlc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBBZGRyZXNzZXNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvbikge1xuICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID1cbiAgICBBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcihjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgYmxvY2tjaGFpbiBhZGRyZXNzIGZvciBhIHdhbGxldCBmb3IgYSBnaXZlbiBjdXJyZW5jeS9jaGFpbiBwYWlyLiBDaXJjbGUgbWF5IHJldXNlIGFkZHJlc3NlcyBvbiBibG9ja2NoYWlucyB0aGF0IHN1cHBvcnQgcmV1c2UuIEZvciBleGFtcGxlLCBpZiB5b3VcXCdyZSByZXF1ZXN0aW5nIHR3byBhZGRyZXNzZXMgZm9yIGRlcG9zaXRpbmcgVVNEIGFuZCBFVEgsIGJvdGggb24gRXRoZXJldW0sIHlvdSBtYXkgc2VlIHRoZSBzYW1lIEV0aGVyZXVtIGFkZHJlc3MgcmV0dXJuZWQuIERlcG9zaXRpbmcgY3J5cHRvY3VycmVuY3kgdG8gYSBnZW5lcmF0ZWQgYWRkcmVzcyB3aWxsIGNyZWRpdCB0aGUgYXNzb2NpYXRlZCB3YWxsZXQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGRlcG9zaXQuIE5vdGU6IENpcmNsZSBNaW50IFNpbmdhcG9yZSBjdXN0b21lcnMgbXVzdCB2ZXJpZnkgYWxsIHRyYW5zZmVyIHJlY2lwaWVudHMgdXNpbmcgdGhlIFVJIGluIHRoZSBDaXJjbGUgQ29uc29sZSwgYXMgdHJhbnNmZXJzIGZyb20gdW52ZXJpZmllZCBhZGRyZXNzZXMgd2lsbCBiZSBoZWxkIGluIGBwZW5kaW5nYCBzdGF0dXMuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgZGVwb3NpdCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtCdXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3R9IFtidXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJ1c2luZXNzRGVwb3NpdEFkZHJlc3MoXG4gICAgICBidXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3Q/OiBCdXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3QsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8Q3JlYXRlQnVzaW5lc3NEZXBvc2l0QWRkcmVzc1Jlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUJ1c2luZXNzRGVwb3NpdEFkZHJlc3MoXG4gICAgICAgICAgYnVzaW5lc3NHZW5lcmF0ZUFkZHJlc3NSZXF1ZXN0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGFuIGV4dGVybmFsIGJsb2NrY2hhaW4gYWRkcmVzcy4gT25jZSBhZGRlZCwgdGhlIHJlY2lwaWVudCBhZGRyZXNzIG11c3QgYmUgdmVyaWZpZWQgdG8gZW5zdXJlIHRoYXQgeW91IGtub3cgYW5kIHRydXN0IGVhY2ggbmV3IGFkZHJlc3MuIE5vdGU6IENpcmNsZSBNaW50IFNpbmdhcG9yZSBjdXN0b21lcnMgbXVzdCB2ZXJpZnkgYWxsIHRyYW5zZmVyIHJlY2lwaWVudHMgdXNpbmcgdGhlIFVJIGluIHRoZSBDaXJjbGUgQ29uc29sZSwgYXMgdHJhbnNmZXJzIGZyb20gdW52ZXJpZmllZCBhZGRyZXNzZXMgd2lsbCBiZSBoZWxkIGluIGBwZW5kaW5nYCBzdGF0dXMuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcmVjaXBpZW50IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge0J1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzKFxuICAgICAgYnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPENyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc1Jlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzcyhcbiAgICAgICAgICBidXNpbmVzc1JlY2lwaWVudEFkZHJlc3NDcmVhdGlvblJlcXVlc3QsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIGRlcG9zaXQgYWRkcmVzc2VzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEJ1c2luZXNzRGVwb3NpdEFkZHJlc3MoXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8R2V0QnVzaW5lc3NEZXBvc2l0QWRkcmVzc1Jlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEJ1c2luZXNzRGVwb3NpdEFkZHJlc3Mob3B0aW9ucyk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgdGhhdCBoYXZlIGVhY2ggYmVlbiB2ZXJpZmllZCBhbmQgYXJlIGVsaWdpYmxlIGZvciB0cmFuc2ZlcnMuIEFueSByZWNpcGllbnQgYWRkcmVzc2VzIHBlbmRpbmcgdmVyaWZpY2F0aW9uIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHJlY2lwaWVudCBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUJlZm9yZV0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGVuZCBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYmVmb3JlIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VBZnRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgbGlzdEJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc2VzKFxuICAgICAgZnJvbT86IHN0cmluZyxcbiAgICAgIHRvPzogc3RyaW5nLFxuICAgICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPExpc3RCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3Nlc1Jlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3NlcyhcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBhZ2VCZWZvcmUsXG4gICAgICAgICAgcGFnZUFmdGVyLFxuICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQWRkcmVzc2VzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IEFkZHJlc3Nlc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uLFxuICBiYXNlUGF0aD86IHN0cmluZyxcbiAgYXhpb3M/OiBBeGlvc0luc3RhbmNlXG4pIHtcbiAgY29uc3QgbG9jYWxWYXJGcCA9IEFkZHJlc3Nlc0FwaUZwKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBibG9ja2NoYWluIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGZvciBhIGdpdmVuIGN1cnJlbmN5L2NoYWluIHBhaXIuIENpcmNsZSBtYXkgcmV1c2UgYWRkcmVzc2VzIG9uIGJsb2NrY2hhaW5zIHRoYXQgc3VwcG9ydCByZXVzZS4gRm9yIGV4YW1wbGUsIGlmIHlvdVxcJ3JlIHJlcXVlc3RpbmcgdHdvIGFkZHJlc3NlcyBmb3IgZGVwb3NpdGluZyBVU0QgYW5kIEVUSCwgYm90aCBvbiBFdGhlcmV1bSwgeW91IG1heSBzZWUgdGhlIHNhbWUgRXRoZXJldW0gYWRkcmVzcyByZXR1cm5lZC4gRGVwb3NpdGluZyBjcnlwdG9jdXJyZW5jeSB0byBhIGdlbmVyYXRlZCBhZGRyZXNzIHdpbGwgY3JlZGl0IHRoZSBhc3NvY2lhdGVkIHdhbGxldCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZGVwb3NpdC4gTm90ZTogQ2lyY2xlIE1pbnQgU2luZ2Fwb3JlIGN1c3RvbWVycyBtdXN0IHZlcmlmeSBhbGwgdHJhbnNmZXIgcmVjaXBpZW50cyB1c2luZyB0aGUgVUkgaW4gdGhlIENpcmNsZSBDb25zb2xlLCBhcyB0cmFuc2ZlcnMgZnJvbSB1bnZlcmlmaWVkIGFkZHJlc3NlcyB3aWxsIGJlIGhlbGQgaW4gYHBlbmRpbmdgIHN0YXR1cy5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBkZXBvc2l0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge0J1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdH0gW2J1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlQnVzaW5lc3NEZXBvc2l0QWRkcmVzcyhcbiAgICAgIGJ1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdD86IEJ1c2luZXNzR2VuZXJhdGVBZGRyZXNzUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8Q3JlYXRlQnVzaW5lc3NEZXBvc2l0QWRkcmVzc1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuY3JlYXRlQnVzaW5lc3NEZXBvc2l0QWRkcmVzcyhidXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RvcmVzIGFuIGV4dGVybmFsIGJsb2NrY2hhaW4gYWRkcmVzcy4gT25jZSBhZGRlZCwgdGhlIHJlY2lwaWVudCBhZGRyZXNzIG11c3QgYmUgdmVyaWZpZWQgdG8gZW5zdXJlIHRoYXQgeW91IGtub3cgYW5kIHRydXN0IGVhY2ggbmV3IGFkZHJlc3MuIE5vdGU6IENpcmNsZSBNaW50IFNpbmdhcG9yZSBjdXN0b21lcnMgbXVzdCB2ZXJpZnkgYWxsIHRyYW5zZmVyIHJlY2lwaWVudHMgdXNpbmcgdGhlIFVJIGluIHRoZSBDaXJjbGUgQ29uc29sZSwgYXMgdHJhbnNmZXJzIGZyb20gdW52ZXJpZmllZCBhZGRyZXNzZXMgd2lsbCBiZSBoZWxkIGluIGBwZW5kaW5nYCBzdGF0dXMuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcmVjaXBpZW50IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge0J1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlQnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzKFxuICAgICAgYnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxDcmVhdGVCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3NSZXNwb25zZT4ge1xuICAgICAgcmV0dXJuIGxvY2FsVmFyRnBcbiAgICAgICAgLmNyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzcyhcbiAgICAgICAgICBidXNpbmVzc1JlY2lwaWVudEFkZHJlc3NDcmVhdGlvblJlcXVlc3QsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBkZXBvc2l0IGFkZHJlc3Nlc1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRCdXNpbmVzc0RlcG9zaXRBZGRyZXNzKFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxHZXRCdXNpbmVzc0RlcG9zaXRBZGRyZXNzUmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5nZXRCdXNpbmVzc0RlcG9zaXRBZGRyZXNzKG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcmVjaXBpZW50IGFkZHJlc3NlcyB0aGF0IGhhdmUgZWFjaCBiZWVuIHZlcmlmaWVkIGFuZCBhcmUgZWxpZ2libGUgZm9yIHRyYW5zZmVycy4gQW55IHJlY2lwaWVudCBhZGRyZXNzZXMgcGVuZGluZyB2ZXJpZmljYXRpb24gYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICogQHN1bW1hcnkgTGlzdCBhbGwgcmVjaXBpZW50IGFkZHJlc3Nlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0QnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzZXMoXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPExpc3RCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3Nlc1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAubGlzdEJ1c2luZXNzUmVjaXBpZW50QWRkcmVzc2VzKFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQWRkcmVzc2VzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEFkZHJlc3Nlc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBBZGRyZXNzZXNBcGkgZXh0ZW5kcyBCYXNlQVBJIHtcbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIG5ldyBibG9ja2NoYWluIGFkZHJlc3MgZm9yIGEgd2FsbGV0IGZvciBhIGdpdmVuIGN1cnJlbmN5L2NoYWluIHBhaXIuIENpcmNsZSBtYXkgcmV1c2UgYWRkcmVzc2VzIG9uIGJsb2NrY2hhaW5zIHRoYXQgc3VwcG9ydCByZXVzZS4gRm9yIGV4YW1wbGUsIGlmIHlvdVxcJ3JlIHJlcXVlc3RpbmcgdHdvIGFkZHJlc3NlcyBmb3IgZGVwb3NpdGluZyBVU0QgYW5kIEVUSCwgYm90aCBvbiBFdGhlcmV1bSwgeW91IG1heSBzZWUgdGhlIHNhbWUgRXRoZXJldW0gYWRkcmVzcyByZXR1cm5lZC4gRGVwb3NpdGluZyBjcnlwdG9jdXJyZW5jeSB0byBhIGdlbmVyYXRlZCBhZGRyZXNzIHdpbGwgY3JlZGl0IHRoZSBhc3NvY2lhdGVkIHdhbGxldCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGUgZGVwb3NpdC4gTm90ZTogQ2lyY2xlIE1pbnQgU2luZ2Fwb3JlIGN1c3RvbWVycyBtdXN0IHZlcmlmeSBhbGwgdHJhbnNmZXIgcmVjaXBpZW50cyB1c2luZyB0aGUgVUkgaW4gdGhlIENpcmNsZSBDb25zb2xlLCBhcyB0cmFuc2ZlcnMgZnJvbSB1bnZlcmlmaWVkIGFkZHJlc3NlcyB3aWxsIGJlIGhlbGQgaW4gYHBlbmRpbmdgIHN0YXR1cy5cbiAgICogQHN1bW1hcnkgQ3JlYXRlIGEgZGVwb3NpdCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7QnVzaW5lc3NHZW5lcmF0ZUFkZHJlc3NSZXF1ZXN0fSBbYnVzaW5lc3NHZW5lcmF0ZUFkZHJlc3NSZXF1ZXN0XVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlQnVzaW5lc3NEZXBvc2l0QWRkcmVzcyhcbiAgICBidXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3Q/OiBCdXNpbmVzc0dlbmVyYXRlQWRkcmVzc1JlcXVlc3QsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gQWRkcmVzc2VzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmNyZWF0ZUJ1c2luZXNzRGVwb3NpdEFkZHJlc3MoYnVzaW5lc3NHZW5lcmF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyBhbiBleHRlcm5hbCBibG9ja2NoYWluIGFkZHJlc3MuIE9uY2UgYWRkZWQsIHRoZSByZWNpcGllbnQgYWRkcmVzcyBtdXN0IGJlIHZlcmlmaWVkIHRvIGVuc3VyZSB0aGF0IHlvdSBrbm93IGFuZCB0cnVzdCBlYWNoIG5ldyBhZGRyZXNzLiBOb3RlOiBDaXJjbGUgTWludCBTaW5nYXBvcmUgY3VzdG9tZXJzIG11c3QgdmVyaWZ5IGFsbCB0cmFuc2ZlciByZWNpcGllbnRzIHVzaW5nIHRoZSBVSSBpbiB0aGUgQ2lyY2xlIENvbnNvbGUsIGFzIHRyYW5zZmVycyBmcm9tIHVudmVyaWZpZWQgYWRkcmVzc2VzIHdpbGwgYmUgaGVsZCBpbiBgcGVuZGluZ2Agc3RhdHVzLlxuICAgKiBAc3VtbWFyeSBDcmVhdGUgYSByZWNpcGllbnQgYWRkcmVzc1xuICAgKiBAcGFyYW0ge0J1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzUmVjaXBpZW50QWRkcmVzc0NyZWF0aW9uUmVxdWVzdF1cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzcyhcbiAgICBidXNpbmVzc1JlY2lwaWVudEFkZHJlc3NDcmVhdGlvblJlcXVlc3Q/OiBCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3NDcmVhdGlvblJlcXVlc3QsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gQWRkcmVzc2VzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmNyZWF0ZUJ1c2luZXNzUmVjaXBpZW50QWRkcmVzcyhcbiAgICAgICAgYnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHN1bW1hcnkgTGlzdCBhbGwgZGVwb3NpdCBhZGRyZXNzZXNcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgKi9cbiAgcHVibGljIGdldEJ1c2luZXNzRGVwb3NpdEFkZHJlc3Mob3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZykge1xuICAgIHJldHVybiBBZGRyZXNzZXNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuZ2V0QnVzaW5lc3NEZXBvc2l0QWRkcmVzcyhvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgdGhhdCBoYXZlIGVhY2ggYmVlbiB2ZXJpZmllZCBhbmQgYXJlIGVsaWdpYmxlIGZvciB0cmFuc2ZlcnMuIEFueSByZWNpcGllbnQgYWRkcmVzc2VzIHBlbmRpbmcgdmVyaWZpY2F0aW9uIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgKiBAc3VtbWFyeSBMaXN0IGFsbCByZWNpcGllbnQgYWRkcmVzc2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgKi9cbiAgcHVibGljIGxpc3RCdXNpbmVzc1JlY2lwaWVudEFkZHJlc3NlcyhcbiAgICBmcm9tPzogc3RyaW5nLFxuICAgIHRvPzogc3RyaW5nLFxuICAgIHBhZ2VCZWZvcmU/OiBzdHJpbmcsXG4gICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIEFkZHJlc3Nlc0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5saXN0QnVzaW5lc3NSZWNpcGllbnRBZGRyZXNzZXMoXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBwYWdlQmVmb3JlLFxuICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgIHBhZ2VTaXplLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cbn1cbiJdfQ==