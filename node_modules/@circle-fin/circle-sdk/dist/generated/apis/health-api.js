"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HealthApi = exports.HealthApiFactory = exports.HealthApiFp = exports.HealthApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * HealthApi - axios parameter creator
 * @export
 */
const HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Checks that the service is running.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.HealthApiAxiosParamCreator = HealthApiAxiosParamCreator;
/**
 * HealthApi - functional programming interface
 * @export
 */
const HealthApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.HealthApiAxiosParamCreator)(configuration);
    return {
        /**
         * Checks that the service is running.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ping(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.HealthApiFp = HealthApiFp;
/**
 * HealthApi - factory interface
 * @export
 */
const HealthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.HealthApiFp)(configuration);
    return {
        /**
         * Checks that the service is running.
         * @summary Ping
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options) {
            return localVarFp
                .ping(options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.HealthApiFactory = HealthApiFactory;
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends base_1.BaseAPI {
    /**
     * Checks that the service is running.
     * @summary Ping
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    ping(options) {
        return (0, exports.HealthApiFp)(this.configuration)
            .ping(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.HealthApi = HealthApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVhbHRoLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9nZW5lcmF0ZWQvYXBpcy9oZWFsdGgtYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCOzs7O0dBSUc7Ozs7Ozs7Ozs7Ozs7OztBQUVILGtEQUllO0FBRWYseURBQXlEO0FBQ3pELGFBQWE7QUFDYixzQ0FRbUI7QUFDbkIsYUFBYTtBQUNiLGtDQU1pQjtBQUdqQjs7O0dBR0c7QUFDSSxNQUFNLDBCQUEwQixHQUFHLFVBQ3hDLGFBQTZCO0lBRTdCLE9BQU87UUFDTDs7Ozs7V0FLRztRQUNILElBQUksRUFBRSxDQUFPLFVBQThCLEVBQUUsRUFBd0IsRUFBRTtZQUNyRSxNQUFNLFlBQVksR0FBRyxPQUFPLENBQUM7WUFDN0Isb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxLQUFLLElBQ1YsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO0tBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQztBQTFDVyxRQUFBLDBCQUEwQiw4QkEwQ3JDO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSxXQUFXLEdBQUcsVUFBVSxhQUE2QjtJQUNoRSxNQUFNLHlCQUF5QixHQUFHLElBQUEsa0NBQTBCLEVBQUMsYUFBYSxDQUFDLENBQUM7SUFDNUUsT0FBTztRQUNMOzs7OztXQUtHO1FBQ0csSUFBSSxDQUNSLE9BQTRCOztnQkFJNUIsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLHlCQUF5QixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDeEUsT0FBTyxJQUFBLDhCQUFxQixFQUMxQixpQkFBaUIsRUFDakIsZUFBVyxFQUNYLGdCQUFTLEVBQ1QsYUFBYSxDQUNkLENBQUM7WUFDSixDQUFDO1NBQUE7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBdkJXLFFBQUEsV0FBVyxlQXVCdEI7QUFFRjs7O0dBR0c7QUFDSSxNQUFNLGdCQUFnQixHQUFHLFVBQzlCLGFBQTZCLEVBQzdCLFFBQWlCLEVBQ2pCLEtBQXFCO0lBRXJCLE1BQU0sVUFBVSxHQUFHLElBQUEsbUJBQVcsRUFBQyxhQUFhLENBQUMsQ0FBQztJQUM5QyxPQUFPO1FBQ0w7Ozs7O1dBS0c7UUFDSCxJQUFJLENBQUMsT0FBYTtZQUNoQixPQUFPLFVBQVU7aUJBQ2QsSUFBSSxDQUFDLE9BQU8sQ0FBQztpQkFDYixJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDO0tBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQztBQW5CVyxRQUFBLGdCQUFnQixvQkFtQjNCO0FBRUY7Ozs7O0dBS0c7QUFDSCxNQUFhLFNBQVUsU0FBUSxjQUFPO0lBQ3BDOzs7Ozs7T0FNRztJQUNJLElBQUksQ0FBQyxPQUE0QjtRQUN0QyxPQUFPLElBQUEsbUJBQVcsRUFBQyxJQUFJLENBQUMsYUFBYSxDQUFDO2FBQ25DLElBQUksQ0FBQyxPQUFPLENBQUM7YUFDYixJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7Q0FDRjtBQWJELDhCQWFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuXG5pbXBvcnQgZ2xvYmFsQXhpb3MsIHtcbiAgQXhpb3NQcm9taXNlLFxuICBBeGlvc0luc3RhbmNlLFxuICBBeGlvc1JlcXVlc3RDb25maWdcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbmZpZ3VyYXRpb25cIjtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHtcbiAgRFVNTVlfQkFTRV9VUkwsXG4gIGFzc2VydFBhcmFtRXhpc3RzLFxuICBzZXRCZWFyZXJBdXRoVG9PYmplY3QsXG4gIHNldFNlYXJjaFBhcmFtcyxcbiAgc2VyaWFsaXplRGF0YUlmTmVlZGVkLFxuICB0b1BhdGhTdHJpbmcsXG4gIGNyZWF0ZVJlcXVlc3RGdW5jdGlvblxufSBmcm9tIFwiLi4vY29tbW9uXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBCQVNFX1BBVEgsXG4gIENPTExFQ1RJT05fRk9STUFUUyxcbiAgUmVxdWVzdEFyZ3MsXG4gIEJhc2VBUEksXG4gIFJlcXVpcmVkRXJyb3Jcbn0gZnJvbSBcIi4uL2Jhc2VcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IFBpbmcgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vKipcbiAqIEhlYWx0aEFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBIZWFsdGhBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb25cbikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0aGF0IHRoZSBzZXJ2aWNlIGlzIHJ1bm5pbmcuXG4gICAgICogQHN1bW1hcnkgUGluZ1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBwaW5nOiBhc3luYyAob3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge30pOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3BpbmdgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEhlYWx0aEFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBIZWFsdGhBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvbikge1xuICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gSGVhbHRoQXBpQXhpb3NQYXJhbUNyZWF0b3IoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIHNlcnZpY2UgaXMgcnVubmluZy5cbiAgICAgKiBAc3VtbWFyeSBQaW5nXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIHBpbmcoXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChheGlvcz86IEF4aW9zSW5zdGFuY2UsIGJhc2VQYXRoPzogc3RyaW5nKSA9PiBBeGlvc1Byb21pc2U8UGluZz5cbiAgICA+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5waW5nKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBIZWFsdGhBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgSGVhbHRoQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb24sXG4gIGJhc2VQYXRoPzogc3RyaW5nLFxuICBheGlvcz86IEF4aW9zSW5zdGFuY2Vcbikge1xuICBjb25zdCBsb2NhbFZhckZwID0gSGVhbHRoQXBpRnAoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIHNlcnZpY2UgaXMgcnVubmluZy5cbiAgICAgKiBAc3VtbWFyeSBQaW5nXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIHBpbmcob3B0aW9ucz86IGFueSk6IEF4aW9zUHJvbWlzZTxQaW5nPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAucGluZyhvcHRpb25zKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEhlYWx0aEFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBIZWFsdGhBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5leHBvcnQgY2xhc3MgSGVhbHRoQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gIC8qKlxuICAgKiBDaGVja3MgdGhhdCB0aGUgc2VydmljZSBpcyBydW5uaW5nLlxuICAgKiBAc3VtbWFyeSBQaW5nXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBIZWFsdGhBcGlcbiAgICovXG4gIHB1YmxpYyBwaW5nKG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWcpIHtcbiAgICByZXR1cm4gSGVhbHRoQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLnBpbmcob3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxufVxuIl19