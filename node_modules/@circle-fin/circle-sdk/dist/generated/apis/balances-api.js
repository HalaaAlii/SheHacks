"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BalancesApi = exports.BalancesApiFactory = exports.BalancesApiFp = exports.BalancesApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * BalancesApi - axios parameter creator
 * @export
 */
const BalancesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * Retrieves the balance of funds that are available for use.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessBalances: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.BalancesApiAxiosParamCreator = BalancesApiAxiosParamCreator;
/**
 * BalancesApi - functional programming interface
 * @export
 */
const BalancesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BalancesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBalances(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieves the balance of funds that are available for use.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessBalances(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBusinessBalances(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.BalancesApiFp = BalancesApiFp;
/**
 * BalancesApi - factory interface
 * @export
 */
const BalancesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BalancesApiFp)(configuration);
    return {
        /**
         * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBalances(options) {
            return localVarFp
                .listBalances(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the balance of funds that are available for use.
         * @summary List all balances
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessBalances(options) {
            return localVarFp
                .listBusinessBalances(options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.BalancesApiFactory = BalancesApiFactory;
/**
 * BalancesApi - object-oriented interface
 * @export
 * @class BalancesApi
 * @extends {BaseAPI}
 */
class BalancesApi extends base_1.BaseAPI {
    /**
     * Retrieves the balance of merchant funds that have settled and also of funds that have been sent for processing but have not yet settled.
     * @summary List all balances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    listBalances(options) {
        return (0, exports.BalancesApiFp)(this.configuration)
            .listBalances(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the balance of funds that are available for use.
     * @summary List all balances
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalancesApi
     */
    listBusinessBalances(options) {
        return (0, exports.BalancesApiFp)(this.configuration)
            .listBusinessBalances(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.BalancesApi = BalancesApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsYW5jZXMtYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2dlbmVyYXRlZC9hcGlzL2JhbGFuY2VzLWFwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7QUFFSCxrREFJZTtBQUVmLHlEQUF5RDtBQUN6RCxhQUFhO0FBQ2Isc0NBUW1CO0FBQ25CLGFBQWE7QUFDYixrQ0FNaUI7QUFPakI7OztHQUdHO0FBQ0ksTUFBTSw0QkFBNEIsR0FBRyxVQUMxQyxhQUE2QjtJQUU3QixPQUFPO1FBQ0w7Ozs7O1dBS0c7UUFDSCxZQUFZLEVBQUUsQ0FDWixVQUE4QixFQUFFLEVBQ1YsRUFBRTtZQUN4QixNQUFNLFlBQVksR0FBRyxjQUFjLENBQUM7WUFDcEMsb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxLQUFLLElBQ1YsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMs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ZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5cbmltcG9ydCBnbG9iYWxBeGlvcywge1xuICBBeGlvc1Byb21pc2UsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZ1xufSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29uZmlndXJhdGlvblwiO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBEVU1NWV9CQVNFX1VSTCxcbiAgYXNzZXJ0UGFyYW1FeGlzdHMsXG4gIHNldEJlYXJlckF1dGhUb09iamVjdCxcbiAgc2V0U2VhcmNoUGFyYW1zLFxuICBzZXJpYWxpemVEYXRhSWZOZWVkZWQsXG4gIHRvUGF0aFN0cmluZyxcbiAgY3JlYXRlUmVxdWVzdEZ1bmN0aW9uXG59IGZyb20gXCIuLi9jb21tb25cIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7XG4gIEJBU0VfUEFUSCxcbiAgQ09MTEVDVElPTl9GT1JNQVRTLFxuICBSZXF1ZXN0QXJncyxcbiAgQmFzZUFQSSxcbiAgUmVxdWlyZWRFcnJvclxufSBmcm9tIFwiLi4vYmFzZVwiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgTGlzdEJhbGFuY2VzUmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBMaXN0QnVzaW5lc3NCYWxhbmNlc1Jlc3BvbnNlIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgTm90QXV0aG9yaXplZCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8qKlxuICogQmFsYW5jZXNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgQmFsYW5jZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb25cbikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYmFsYW5jZSBvZiBtZXJjaGFudCBmdW5kcyB0aGF0IGhhdmUgc2V0dGxlZCBhbmQgYWxzbyBvZiBmdW5kcyB0aGF0IGhhdmUgYmVlbiBzZW50IGZvciBwcm9jZXNzaW5nIGJ1dCBoYXZlIG5vdCB5ZXQgc2V0dGxlZC5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBiYWxhbmNlc1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0QmFsYW5jZXM6IGFzeW5jIChcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9iYWxhbmNlc2A7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYmFsYW5jZSBvZiBmdW5kcyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBiYWxhbmNlc1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0QnVzaW5lc3NCYWxhbmNlczogYXN5bmMgKFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2J1c2luZXNzQWNjb3VudC9iYWxhbmNlc2A7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIEJhbGFuY2VzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IEJhbGFuY2VzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9IEJhbGFuY2VzQXBpQXhpb3NQYXJhbUNyZWF0b3IoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBiYWxhbmNlIG9mIG1lcmNoYW50IGZ1bmRzIHRoYXQgaGF2ZSBzZXR0bGVkIGFuZCBhbHNvIG9mIGZ1bmRzIHRoYXQgaGF2ZSBiZWVuIHNlbnQgZm9yIHByb2Nlc3NpbmcgYnV0IGhhdmUgbm90IHlldCBzZXR0bGVkLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIGJhbGFuY2VzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RCYWxhbmNlcyhcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxMaXN0QmFsYW5jZXNSZXNwb25zZT5cbiAgICA+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QmFsYW5jZXMoXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYmFsYW5jZSBvZiBmdW5kcyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHVzZS5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBiYWxhbmNlc1xuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QnVzaW5lc3NCYWxhbmNlcyhcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxMaXN0QnVzaW5lc3NCYWxhbmNlc1Jlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RCdXNpbmVzc0JhbGFuY2VzKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBCYWxhbmNlc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBCYWxhbmNlc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uLFxuICBiYXNlUGF0aD86IHN0cmluZyxcbiAgYXhpb3M/OiBBeGlvc0luc3RhbmNlXG4pIHtcbiAgY29uc3QgbG9jYWxWYXJGcCA9IEJhbGFuY2VzQXBpRnAoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBiYWxhbmNlIG9mIG1lcmNoYW50IGZ1bmRzIHRoYXQgaGF2ZSBzZXR0bGVkIGFuZCBhbHNvIG9mIGZ1bmRzIHRoYXQgaGF2ZSBiZWVuIHNlbnQgZm9yIHByb2Nlc3NpbmcgYnV0IGhhdmUgbm90IHlldCBzZXR0bGVkLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIGJhbGFuY2VzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGxpc3RCYWxhbmNlcyhvcHRpb25zPzogYW55KTogQXhpb3NQcm9taXNlPExpc3RCYWxhbmNlc1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAubGlzdEJhbGFuY2VzKG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBiYWxhbmNlIG9mIGZ1bmRzIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIGJhbGFuY2VzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGxpc3RCdXNpbmVzc0JhbGFuY2VzKFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxMaXN0QnVzaW5lc3NCYWxhbmNlc1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAubGlzdEJ1c2luZXNzQmFsYW5jZXMob3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBCYWxhbmNlc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBCYWxhbmNlc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBCYWxhbmNlc0FwaSBleHRlbmRzIEJhc2VBUEkge1xuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBiYWxhbmNlIG9mIG1lcmNoYW50IGZ1bmRzIHRoYXQgaGF2ZSBzZXR0bGVkIGFuZCBhbHNvIG9mIGZ1bmRzIHRoYXQgaGF2ZSBiZWVuIHNlbnQgZm9yIHByb2Nlc3NpbmcgYnV0IGhhdmUgbm90IHlldCBzZXR0bGVkLlxuICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBiYWxhbmNlc1xuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgQmFsYW5jZXNBcGlcbiAgICovXG4gIHB1YmxpYyBsaXN0QmFsYW5jZXMob3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZykge1xuICAgIHJldHVybiBCYWxhbmNlc0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5saXN0QmFsYW5jZXMob3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGJhbGFuY2Ugb2YgZnVuZHMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gICAqIEBzdW1tYXJ5IExpc3QgYWxsIGJhbGFuY2VzXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBCYWxhbmNlc0FwaVxuICAgKi9cbiAgcHVibGljIGxpc3RCdXNpbmVzc0JhbGFuY2VzKG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWcpIHtcbiAgICByZXR1cm4gQmFsYW5jZXNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAubGlzdEJ1c2luZXNzQmFsYW5jZXMob3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxufVxuIl19