"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentTokensApi = exports.PaymentTokensApiFactory = exports.PaymentTokensApiFp = exports.PaymentTokensApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * PaymentTokensApi - axios parameter creator
 * @export
 */
const PaymentTokensApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Convert a digital wallet (Apple Pay, Google Pay) token to a single-use payment token.
         * @summary Create a payment token
         * @param {PaymentTokenRequest} [paymentTokenRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken: (paymentTokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/paymentTokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(paymentTokenRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.PaymentTokensApiAxiosParamCreator = PaymentTokensApiAxiosParamCreator;
/**
 * PaymentTokensApi - functional programming interface
 * @export
 */
const PaymentTokensApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentTokensApiAxiosParamCreator)(configuration);
    return {
        /**
         * Convert a digital wallet (Apple Pay, Google Pay) token to a single-use payment token.
         * @summary Create a payment token
         * @param {PaymentTokenRequest} [paymentTokenRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(paymentTokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentToken(paymentTokenRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.PaymentTokensApiFp = PaymentTokensApiFp;
/**
 * PaymentTokensApi - factory interface
 * @export
 */
const PaymentTokensApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentTokensApiFp)(configuration);
    return {
        /**
         * Convert a digital wallet (Apple Pay, Google Pay) token to a single-use payment token.
         * @summary Create a payment token
         * @param {PaymentTokenRequest} [paymentTokenRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentToken(paymentTokenRequest, options) {
            return localVarFp
                .createPaymentToken(paymentTokenRequest, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.PaymentTokensApiFactory = PaymentTokensApiFactory;
/**
 * PaymentTokensApi - object-oriented interface
 * @export
 * @class PaymentTokensApi
 * @extends {BaseAPI}
 */
class PaymentTokensApi extends base_1.BaseAPI {
    /**
     * Convert a digital wallet (Apple Pay, Google Pay) token to a single-use payment token.
     * @summary Create a payment token
     * @param {PaymentTokenRequest} [paymentTokenRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTokensApi
     */
    createPaymentToken(paymentTokenRequest, options) {
        return (0, exports.PaymentTokensApiFp)(this.configuration)
            .createPaymentToken(paymentTokenRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentTokensApi = PaymentTokensApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF5bWVudC10b2tlbnMtYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2dlbmVyYXRlZC9hcGlzL3BheW1lbnQtdG9rZW5zLWFwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7QUFFSCxrREFJZTtBQUVmLHlEQUF5RDtBQUN6RCxhQUFhO0FBQ2Isc0NBUW1CO0FBQ25CLGFBQWE7QUFDYixrQ0FNaUI7QUFTakI7OztHQUdHO0FBQ0ksTUFBTSxpQ0FBaUMsR0FBRyxVQUMvQyxhQUE2QjtJQUU3QixPQUFPO1FBQ0w7Ozs7OztXQU1HO1FBQ0gsa0JBQWtCLEVBQUUsQ0FDbEIsbUJBQXlDLEVBQ3pDLFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLG1CQUFtQixDQUFDO1lBQ3pDLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsTUFBTSxJQUNYLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDO1lBRTdELElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJQUFJLHNCQUFzQixHQUN4QixXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLHNCQUFzQixDQUFDLE9BQU8saURBQ3pCLHVCQUF1QixHQUN2QixzQkFBc0IsR0FDdEIsT0FBTyxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztZQUNGLHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFBLDhCQUFxQixFQUNqRCxtQkFBbUIsRUFDbkIsc0JBQXNCLEVBQ3RCLGFBQWEsQ0FDZCxDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO0tBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQztBQXpEVyxRQUFBLGlDQUFpQyxxQ0F5RDVDO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSxrQkFBa0IsR0FBRyxVQUFVLGFBQTZCO0lBQ3ZFLE1BQU0seUJBQXlCLEdBQzdCLElBQUEseUNBQWlDLEVBQUMsYUFBYSxDQUFDLENBQUM7SUFDbkQsT0FBTztRQUNMOzs7Ozs7V0FNRztRQUNHLGtCQUFrQixDQUN0QixtQkFBeUMsRUFDekMsT0FBNEI7O2dCQU81QixNQUFNLGlCQUFpQixHQUNyQixNQUFNLHlCQUF5QixDQUFDLGtCQUFrQixDQUNoRCxtQkFBbUIsRUFDbkIsT0FBTyxDQUNSLENBQUM7Z0JBQ0osT0FBTyxJQUFBLDhCQUFxQixFQUMxQixpQkFBaUIsRUFDakIsZUFBVyxFQUNYLGdCQUFTLEVBQ1QsYUFBYSxDQUNkLENBQUM7WUFDSixDQUFDO1NBQUE7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBakNXLFFBQUEsa0JBQWtCLHNCQWlDN0I7QUFFRjs7O0dBR0c7QUFDSSxNQUFNLHVCQUF1QixHQUFHLFVBQ3JDLGFBQTZCLEVBQzdCLFFBQWlCLEVBQ2pCLEtBQXFCO0lBRXJCLE1BQU0sVUFBVSxHQUFHLElBQUEsMEJBQWtCLEVBQUMsYUFBYSxDQUFDLENBQUM7SUFDckQsT0FBTztRQUNMOzs7Ozs7V0FNRztRQUNILGtCQUFrQixDQUNoQixtQkFBeUMsRUFDekMsT0FBYTtZQUViLE9BQU8sVUFBVTtpQkFDZCxrQkFBa0IsQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLENBQUM7aUJBQ2hELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBdkJXLFFBQUEsdUJBQXVCLDJCQXVCbEM7QUFFRjs7Ozs7R0FLRztBQUNILE1BQWEsZ0JBQWlCLFNBQVEsY0FBTztJQUMzQzs7Ozs7OztPQU9HO0lBQ0ksa0JBQWtCLENBQ3ZCLG1CQUF5QyxFQUN6QyxPQUE0QjtRQUU1QixPQUFPLElBQUEsMEJBQWtCLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUMxQyxrQkFBa0IsQ0FBQyxtQkFBbUIsRUFBRSxPQUFPLENBQUM7YUFDaEQsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0NBQ0Y7QUFqQkQsNENBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuXG5pbXBvcnQgZ2xvYmFsQXhpb3MsIHtcbiAgQXhpb3NQcm9taXNlLFxuICBBeGlvc0luc3RhbmNlLFxuICBBeGlvc1JlcXVlc3RDb25maWdcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbmZpZ3VyYXRpb25cIjtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHtcbiAgRFVNTVlfQkFTRV9VUkwsXG4gIGFzc2VydFBhcmFtRXhpc3RzLFxuICBzZXRCZWFyZXJBdXRoVG9PYmplY3QsXG4gIHNldFNlYXJjaFBhcmFtcyxcbiAgc2VyaWFsaXplRGF0YUlmTmVlZGVkLFxuICB0b1BhdGhTdHJpbmcsXG4gIGNyZWF0ZVJlcXVlc3RGdW5jdGlvblxufSBmcm9tIFwiLi4vY29tbW9uXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBCQVNFX1BBVEgsXG4gIENPTExFQ1RJT05fRk9STUFUUyxcbiAgUmVxdWVzdEFyZ3MsXG4gIEJhc2VBUEksXG4gIFJlcXVpcmVkRXJyb3Jcbn0gZnJvbSBcIi4uL2Jhc2VcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJhZFJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDcmVhdGVQYXltZW50VG9rZW5SZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IE5vdEF1dGhvcml6ZWQgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBQYXltZW50VG9rZW5SZXF1ZXN0IH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLyoqXG4gKiBQYXltZW50VG9rZW5zQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBheW1lbnRUb2tlbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb25cbikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBkaWdpdGFsIHdhbGxldCAoQXBwbGUgUGF5LCBHb29nbGUgUGF5KSB0b2tlbiB0byBhIHNpbmdsZS11c2UgcGF5bWVudCB0b2tlbi5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXltZW50IHRva2VuXG4gICAgICogQHBhcmFtIHtQYXltZW50VG9rZW5SZXF1ZXN0fSBbcGF5bWVudFRva2VuUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlUGF5bWVudFRva2VuOiBhc3luYyAoXG4gICAgICBwYXltZW50VG9rZW5SZXF1ZXN0PzogUGF5bWVudFRva2VuUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9wYXltZW50VG9rZW5zYDtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQoXG4gICAgICAgIHBheW1lbnRUb2tlblJlcXVlc3QsXG4gICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFBheW1lbnRUb2tlbnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgUGF5bWVudFRva2Vuc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uKSB7XG4gIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPVxuICAgIFBheW1lbnRUb2tlbnNBcGlBeGlvc1BhcmFtQ3JlYXRvcihjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgZGlnaXRhbCB3YWxsZXQgKEFwcGxlIFBheSwgR29vZ2xlIFBheSkgdG9rZW4gdG8gYSBzaW5nbGUtdXNlIHBheW1lbnQgdG9rZW4uXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcGF5bWVudCB0b2tlblxuICAgICAqIEBwYXJhbSB7UGF5bWVudFRva2VuUmVxdWVzdH0gW3BheW1lbnRUb2tlblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVBheW1lbnRUb2tlbihcbiAgICAgIHBheW1lbnRUb2tlblJlcXVlc3Q/OiBQYXltZW50VG9rZW5SZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPENyZWF0ZVBheW1lbnRUb2tlblJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVBheW1lbnRUb2tlbihcbiAgICAgICAgICBwYXltZW50VG9rZW5SZXF1ZXN0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUGF5bWVudFRva2Vuc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydCBjb25zdCBQYXltZW50VG9rZW5zQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb24sXG4gIGJhc2VQYXRoPzogc3RyaW5nLFxuICBheGlvcz86IEF4aW9zSW5zdGFuY2Vcbikge1xuICBjb25zdCBsb2NhbFZhckZwID0gUGF5bWVudFRva2Vuc0FwaUZwKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBkaWdpdGFsIHdhbGxldCAoQXBwbGUgUGF5LCBHb29nbGUgUGF5KSB0b2tlbiB0byBhIHNpbmdsZS11c2UgcGF5bWVudCB0b2tlbi5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXltZW50IHRva2VuXG4gICAgICogQHBhcmFtIHtQYXltZW50VG9rZW5SZXF1ZXN0fSBbcGF5bWVudFRva2VuUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlUGF5bWVudFRva2VuKFxuICAgICAgcGF5bWVudFRva2VuUmVxdWVzdD86IFBheW1lbnRUb2tlblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPENyZWF0ZVBheW1lbnRUb2tlblJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuY3JlYXRlUGF5bWVudFRva2VuKHBheW1lbnRUb2tlblJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUGF5bWVudFRva2Vuc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBQYXltZW50VG9rZW5zQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuZXhwb3J0IGNsYXNzIFBheW1lbnRUb2tlbnNBcGkgZXh0ZW5kcyBCYXNlQVBJIHtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSBkaWdpdGFsIHdhbGxldCAoQXBwbGUgUGF5LCBHb29nbGUgUGF5KSB0b2tlbiB0byBhIHNpbmdsZS11c2UgcGF5bWVudCB0b2tlbi5cbiAgICogQHN1bW1hcnkgQ3JlYXRlIGEgcGF5bWVudCB0b2tlblxuICAgKiBAcGFyYW0ge1BheW1lbnRUb2tlblJlcXVlc3R9IFtwYXltZW50VG9rZW5SZXF1ZXN0XVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUGF5bWVudFRva2Vuc0FwaVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZVBheW1lbnRUb2tlbihcbiAgICBwYXltZW50VG9rZW5SZXF1ZXN0PzogUGF5bWVudFRva2VuUmVxdWVzdCxcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBQYXltZW50VG9rZW5zQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmNyZWF0ZVBheW1lbnRUb2tlbihwYXltZW50VG9rZW5SZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG59XG4iXX0=