"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentsApi = exports.PaymentsApiFactory = exports.PaymentsApiFp = exports.PaymentsApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * PaymentsApi - axios parameter creator
 * @export
 */
const PaymentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted.
         * @summary Cancel a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CancelCreationRequest} [cancelCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment: (id, cancelCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("cancelPayment", "id", id);
            const localVarPath = `/v1/payments/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(cancelCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted.
         * @summary Capture a payment (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CaptureCreationRequest} [captureCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment: (id, captureCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("capturePayment", "id", id);
            const localVarPath = `/v1/payments/{id}/capture`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(captureCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
         * @summary Create a mock Wire payment
         * @param {MockWirePaymentRequest} [mockWirePaymentRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMockWirePayment: (mockWirePaymentRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/mocks/payments/wire`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(mockWirePaymentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Create a payment
         * @param {PaymentCreationRequest} [paymentCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment: (paymentCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(paymentCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Get a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("getPayment", "id", id);
            const localVarPath = `/v1/payments/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary List all payments
         * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
         * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
         * @param {string} [paymentIntentId] Queries items with the specified payment intent id.
         * @param {Set<'card'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments: (source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (source !== undefined) {
                localVarQueryParameter["source"] = source;
            }
            if (settlementId !== undefined) {
                localVarQueryParameter["settlementId"] = settlementId;
            }
            if (paymentIntentId !== undefined) {
                localVarQueryParameter["paymentIntentId"] = paymentIntentId;
            }
            if (type) {
                localVarQueryParameter["type"] = Array.from(type);
            }
            if (status !== undefined) {
                localVarQueryParameter["status"] = status;
            }
            if (from !== undefined) {
                localVarQueryParameter["from"] =
                    from instanceof Date ? from.toISOString() : from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] =
                    to instanceof Date ? to.toISOString() : to;
            }
            if (pageBefore !== undefined) {
                localVarQueryParameter["pageBefore"] = pageBefore;
            }
            if (pageAfter !== undefined) {
                localVarQueryParameter["pageAfter"] = pageAfter;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["pageSize"] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted.
         * @summary Refund a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {RefundCreationRequest} [refundCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: (id, refundCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("refundPayment", "id", id);
            const localVarPath = `/v1/payments/{id}/refund`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(refundCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.PaymentsApiAxiosParamCreator = PaymentsApiAxiosParamCreator;
/**
 * PaymentsApi - functional programming interface
 * @export
 */
const PaymentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentsApiAxiosParamCreator)(configuration);
    return {
        /**
         * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted.
         * @summary Cancel a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CancelCreationRequest} [cancelCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(id, cancelCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelPayment(id, cancelCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted.
         * @summary Capture a payment (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CaptureCreationRequest} [captureCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment(id, captureCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.capturePayment(id, captureCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
         * @summary Create a mock Wire payment
         * @param {MockWirePaymentRequest} [mockWirePaymentRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMockWirePayment(mockWirePaymentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createMockWirePayment(mockWirePaymentRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a payment
         * @param {PaymentCreationRequest} [paymentCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(paymentCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPayment(paymentCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayment(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List all payments
         * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
         * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
         * @param {string} [paymentIntentId] Queries items with the specified payment intent id.
         * @param {Set<'card'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listPayments(source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted.
         * @summary Refund a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {RefundCreationRequest} [refundCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(id, refundCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refundPayment(id, refundCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.PaymentsApiFp = PaymentsApiFp;
/**
 * PaymentsApi - factory interface
 * @export
 */
const PaymentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentsApiFp)(configuration);
    return {
        /**
         * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted.
         * @summary Cancel a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CancelCreationRequest} [cancelCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelPayment(id, cancelCreationRequest, options) {
            return localVarFp
                .cancelPayment(id, cancelCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted.
         * @summary Capture a payment (BETA)
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {CaptureCreationRequest} [captureCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        capturePayment(id, captureCreationRequest, options) {
            return localVarFp
                .capturePayment(id, captureCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
         * @summary Create a mock Wire payment
         * @param {MockWirePaymentRequest} [mockWirePaymentRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMockWirePayment(mockWirePaymentRequest, options) {
            return localVarFp
                .createMockWirePayment(mockWirePaymentRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a payment
         * @param {PaymentCreationRequest} [paymentCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPayment(paymentCreationRequest, options) {
            return localVarFp
                .createPayment(paymentCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(id, options) {
            return localVarFp
                .getPayment(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List all payments
         * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
         * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
         * @param {string} [paymentIntentId] Queries items with the specified payment intent id.
         * @param {Set<'card'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
         * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPayments(source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options) {
            return localVarFp
                .listPayments(source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted.
         * @summary Refund a payment
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {RefundCreationRequest} [refundCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(id, refundCreationRequest, options) {
            return localVarFp
                .refundPayment(id, refundCreationRequest, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.PaymentsApiFactory = PaymentsApiFactory;
/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
class PaymentsApi extends base_1.BaseAPI {
    /**
     * The payment will be voided if possible meaning the payment source will not be charged & the payment will never settle. Otherwise, the payment will be refunded meaning the payment source will be charged & the payment will be refunded from deductions of future settlements. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been cancelled; it only means the cancellation request is successfully submitted.
     * @summary Cancel a payment
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CancelCreationRequest} [cancelCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    cancelPayment(id, cancelCreationRequest, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .cancelPayment(id, cancelCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Warning: Please contact Circle support if you are planning on using this feature.  The given amount will be captured for the authorized payment if possible. If no amount is specified, the full amount will be captured. You can only capture once per authorization.  A successful response does *not* mean the payment has been captured. It only means the capture request was successfully submitted.
     * @summary Capture a payment (BETA)
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {CaptureCreationRequest} [captureCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    capturePayment(id, captureCreationRequest, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .capturePayment(id, captureCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * In the sandbox environment, initiate a mock wire payment that mimics the behavior of funds sent through the bank (wire) account linked to master wallet.
     * @summary Create a mock Wire payment
     * @param {MockWirePaymentRequest} [mockWirePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    createMockWirePayment(mockWirePaymentRequest, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .createMockWirePayment(mockWirePaymentRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a payment
     * @param {PaymentCreationRequest} [paymentCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    createPayment(paymentCreationRequest, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .createPayment(paymentCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a payment
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    getPayment(id, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .getPayment(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List all payments
     * @param {string} [source] Universally unique identifier (UUID v4) for the source. Filters results to fetch only payments made from the provdided source.
     * @param {string} [settlementId] Queries items with the specified settlement id. Matches any settlement id if unspecified.
     * @param {string} [paymentIntentId] Queries items with the specified payment intent id.
     * @param {Set<'card'>} [type] Source account type. Filters the results to fetch all payments made from a specified account type. Matches any source type if unspecified.
     * @param {'pending' | 'confirmed' | 'paid' | 'failed' | 'action_required'} [status] Queries items with the specified status. Matches any status if unspecified.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    listPayments(source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .listPayments(source, settlementId, paymentIntentId, type, status, from, to, pageBefore, pageAfter, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The payment source will be refunded if possible. Not all payments are eligible to be cancelled.  A successful response does *not* mean the payment has been refunded; it only means the refund request is successfully submitted.
     * @summary Refund a payment
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {RefundCreationRequest} [refundCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    refundPayment(id, refundCreationRequest, options) {
        return (0, exports.PaymentsApiFp)(this.configuration)
            .refundPayment(id, refundCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentsApi = PaymentsApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGF5bWVudHMtYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2dlbmVyYXRlZC9hcGlzL3BheW1lbnRzLWFwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7QUFFSCxrREFJZTtBQUVmLHlEQUF5RDtBQUN6RCxhQUFhO0FBQ2Isc0NBUW1CO0FBQ25CLGFBQWE7QUFDYixrQ0FNaUI7QUE2QmpCOzs7R0FHRztBQUNJLE1BQU0sNEJBQTRCLEdBQUcsVUFDMUMsYUFBNkI7SUFFN0IsT0FBTztRQUNMOzs7Ozs7O1dBT0c7UUFDSCxhQUFhLEVBQUUsQ0FDYixFQUFVLEVBQ1YscUJBQTZDLEVBQzdDLFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLDBEQUEwRDtZQUMxRCxJQUFBLDBCQUFpQixFQUFDLGVBQWUsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDN0MsTUFBTSxZQUFZLEdBQUcsMEJBQTBCLENBQUMsT0FBTyxDQUNyRCxJQUFJLElBQUksR0FBRyxFQUNYLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUMvQixDQUFDO1lBQ0Ysb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxNQUFNLElBQ1gsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsdUJBQXVCLENBQUMsY0FBYyxDQUFDLEdBQUcsa0JBQWtCLENBQUM7WUFFN0QsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBQ0Ysc0JBQXNCLENBQUMsSUFBSSxHQUFHLElBQUEsOEJBQXFCLEVBQ2pELHFCQUFxQixFQUNyQixzQkFBc0IsRUFDdEIsYUFBYSxDQUNkLENBQUM7WUFFRixPQUFPO2dCQUNMLEdBQUcsRUFBRSxJQUFBLHFCQUFZLEVBQUMsY0FBYyxDQUFDO2dCQUNqQyxPQUFPLEVBQUUsc0JBQXNCO2FBQ2hDLENBQUM7UUFDSixDQUFDLENBQUE7UUFDRDs7Ozs7OztXQU9HO1FBQ0gsY0FBYyxFQUFFLENBQ2QsRUFBVSxFQUNWLHNCQUErQyxFQUMvQyxVQUE4QixFQUFFLEVBQ1YsRUFBRTtZQUN4QiwwREFBMEQ7WUFDMUQsSUFBQSwwQkFBaUIsRUFBQyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDOUMsTUFBTSxZQUFZLEdBQUcsMkJBQTJCLENBQUMsT0FBTyxDQUN0RCxJQUFJLElBQUksR0FBRyxFQUNYLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUMvQixDQUFDO1lBQ0Ysb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxNQUFNLElBQ1gsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsdUJBQXVCLENBQUMsY0FBYyxDQUFDLEdBQUcsa0JBQWtCLENBQUM7WUFFN0QsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBQ0Ysc0JBQXNCLENBQUMsSUFBSSxHQUFHLElBQUEsOEJBQXFCLEVBQ2pELHNCQUFzQixFQUN0QixzQkFBc0IsRUFDdEIsYUFBYSxDQUNkLENBQUM7WUFFRixPQUFPO2dCQUNMLEdBQUcsRUFBRSxJQUFBLHFCQUFZLEVBQUMsY0FBYyxDQUFDO2dCQUNqQyxPQUFPLEVBQUUsc0JBQXNCO2FBQ2hDLENBQUM7UUFDSixDQUFDLENBQUE7UUFDRDs7Ozs7O1dBTUc7UUFDSCxxQkFBcUIsRUFBRSxDQUNyQixzQkFBK0MsRUFDL0MsVUFBOEIsRUFBRSxFQUNWLEVBQUU7WUFDeEIsTUFBTSxZQUFZLEdBQUcseUJBQXlCLENBQUM7WUFDL0Msb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxNQUFNLElBQ1gsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsdUJBQXVCLENBQUMsY0FBYyxDQUFDLEdBQUcsa0JBQWtCLENBQUM7WUFFN0QsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBQ0Ysc0JBQXNCLENBQUMsSUFBSSxHQUFHLElBQUEsOEJBQXFCLEVBQ2pELHNCQUFzQixFQUN0QixzQkFBc0IsRUFDdEIsYUFBYSxDQUNkLENBQUM7WUFFRixPQUFPO2dCQUNMLEdBQUcsRUFBRSxJQUFBLHFCQUFZLEVBQUMsY0FBYyxDQUFDO2dCQUNqQyxPQUFPLEVBQUUsc0JBQXNCO2FBQ2hDLENBQUM7UUFDSixDQUFDLENBQUE7UUFDRDs7Ozs7O1dBTUc7UUFDSCxhQUFhLEVBQUUsQ0FDYixzQkFBK0MsRUFDL0MsVUFBOEIsRUFBRSxFQUNWLEVBQUU7WUFDeEIsTUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFDO1lBQ3BDLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsTUFBTSxJQUNYLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDO1lBRTdELElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJQUFJLHNCQUFzQixHQUN4QixXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLHNCQUFzQixDQUFDLE9BQU8saURBQ3pCLHVCQUF1QixHQUN2QixzQkFBc0IsR0FDdEIsT0FBTyxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztZQUNGLHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFBLDhCQUFxQixFQUNqRCxzQkFBc0IsRUFDdEIsc0JBQXNCLEVBQ3RCLGFBQWEsQ0FDZCxDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBQ0Q7Ozs7OztXQU1HO1FBQ0gsVUFBVSxFQUFFLENBQ1YsRUFBVSxFQUNWLFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLDBEQUEwRDtZQUMxRCxJQUFBLDBCQUFpQixFQUFDLFlBQVksRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDMUMsTUFBTSxZQUFZLEdBQUcsbUJBQW1CLENBQUMsT0FBTyxDQUM5QyxJQUFJLElBQUksR0FBRyxFQUNYLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUMvQixDQUFDO1lBQ0Ysb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxLQUFLLElBQ1YsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBQ0Q7Ozs7Ozs7Ozs7Ozs7OztXQWVHO1FBQ0gsWUFBWSxFQUFFLENBQ1osTUFBZSxFQUNmLFlBQXFCLEVBQ3JCLGVBQXdCLEVBQ3hCLElBQWtCLEVBQ2xCLE1BQXdFLEVBQ3hFLElBQWEsRUFDYixFQUFXLEVBQ1gsVUFBbUIsRUFDbkIsU0FBa0IsRUFDbEIsUUFBaUIsRUFDakIsVUFBOEIsRUFBRSxFQUNWLEVBQUU7WUFDeEIsTUFBTSxZQUFZLEdBQUcsY0FBYyxDQUFDO1lBQ3BDLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsS0FBSyxJQUNWLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDeEIsc0JBQXNCLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDO2FBQzNDO1lBRUQsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO2dCQUM5QixzQkFBc0IsQ0FBQyxjQUFjLENBQUMsR0FBRyxZQUFZLENBQUM7YUFDdkQ7WUFFRCxJQUFJLGVBQWUsS0FBSyxTQUFTLEVBQUU7Z0JBQ2pDLHNCQUFzQixDQUFDLGlCQUFpQixDQUFDLEdBQUcsZUFBZSxDQUFDO2FBQzdEO1lBRUQsSUFBSSxJQUFJLEVBQUU7Z0JBQ1Isc0JBQXNCLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNuRDtZQUVELElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtnQkFDeEIsc0JBQXNCLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxDQUFDO2FBQzNDO1lBRUQsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUN0QixzQkFBc0IsQ0FBQyxNQUFNLENBQUM7b0JBQzNCLElBQVksWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFFLElBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO2FBQ3RFO1lBRUQsSUFBSSxFQUFFLEtBQUssU0FBUyxFQUFFO2dCQUNwQixzQkFBc0IsQ0FBQyxJQUFJLENBQUM7b0JBQ3pCLEVBQVUsWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFFLEVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2FBQ2hFO1lBRUQsSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO2dCQUM1QixzQkFBc0IsQ0FBQyxZQUFZLENBQUMsR0FBRyxVQUFVLENBQUM7YUFDbkQ7WUFFRCxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7Z0JBQzNCLHNCQUFzQixDQUFDLFdBQVcsQ0FBQyxHQUFHLFNBQVMsQ0FBQzthQUNqRDtZQUVELElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtnQkFDMUIsc0JBQXNCLENBQUMsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDO2FBQy9DO1lBRUQsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBQ0Q7Ozs7Ozs7V0FPRztRQUNILGFBQWEsRUFBRSxDQUNiLEVBQVUsRUFDVixxQkFBNkMsRUFDN0MsVUFBOEIsRUFBRSxFQUNWLEVBQUU7WUFDeEIsMERBQTBEO1lBQzFELElBQUEsMEJBQWlCLEVBQUMsZUFBZSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM3QyxNQUFNLFlBQVksR0FBRywwQkFBMEIsQ0FBQyxPQUFPLENBQ3JELElBQUksSUFBSSxHQUFHLEVBQ1gsa0JBQWtCLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQy9CLENBQUM7WUFDRixvRkFBb0Y7WUFDcEYsTUFBTSxjQUFjLEdBQUcsSUFBSSxHQUFHLENBQUMsWUFBWSxFQUFFLHVCQUFjLENBQUMsQ0FBQztZQUM3RCxJQUFJLFdBQVcsQ0FBQztZQUNoQixJQUFJLGFBQWEsRUFBRTtnQkFDakIsV0FBVyxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUM7YUFDekM7WUFFRCxNQUFNLHNCQUFzQixpQ0FDMUIsTUFBTSxFQUFFLE1BQU0sSUFDWCxXQUFXLEdBQ1gsT0FBTyxDQUNYLENBQUM7WUFDRixNQUFNLHVCQUF1QixHQUFHLEVBQVMsQ0FBQztZQUMxQyxNQUFNLHNCQUFzQixHQUFHLEVBQVMsQ0FBQztZQUV6QyxxQ0FBcUM7WUFDckMsc0NBQXNDO1lBQ3RDLE1BQU0sSUFBQSw4QkFBcUIsRUFBQyx1QkFBdUIsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUVwRSx1QkFBdUIsQ0FBQyxjQUFjLENBQUMsR0FBRyxrQkFBa0IsQ0FBQztZQUU3RCxJQUFBLHdCQUFlLEVBQUMsY0FBYyxFQUFFLHNCQUFzQixDQUFDLENBQUM7WUFDeEQsSUFBSSxzQkFBc0IsR0FDeEIsV0FBVyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNoRSxzQkFBc0IsQ0FBQyxPQUFPLGlEQUN6Qix1QkFBdUIsR0FDdkIsc0JBQXNCLEdBQ3RCLE9BQU8sQ0FBQyxPQUFPLENBQ25CLENBQUM7WUFDRixzQkFBc0IsQ0FBQyxJQUFJLEdBQUcsSUFBQSw4QkFBcUIsRUFDakQscUJBQXFCLEVBQ3JCLHNCQUFzQixFQUN0QixhQUFhLENBQ2QsQ0FBQztZQUVGLE9BQU87Z0JBQ0wsR0FBRyxFQUFFLElBQUEscUJBQVksRUFBQyxjQUFjLENBQUM7Z0JBQ2pDLE9BQU8sRUFBRSxzQkFBc0I7YUFDaEMsQ0FBQztRQUNKLENBQUMsQ0FBQTtLQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUF6YlcsUUFBQSw0QkFBNEIsZ0NBeWJ2QztBQUVGOzs7R0FHRztBQUNJLE1BQU0sYUFBYSxHQUFHLFVBQVUsYUFBNkI7SUFDbEUsTUFBTSx5QkFBeUIsR0FBRyxJQUFBLG9DQUE0QixFQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzlFLE9BQU87UUFDTDs7Ozs7OztXQU9HO1FBQ0csYUFBYSxDQUNqQixFQUFVLEVBQ1YscUJBQTZDLEVBQzdDLE9BQTRCOztnQkFPNUIsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLHlCQUF5QixDQUFDLGFBQWEsQ0FDckUsRUFBRSxFQUNGLHFCQUFxQixFQUNyQixPQUFPLENBQ1IsQ0FBQztnQkFDRixPQUFPLElBQUEsOEJBQXFCLEVBQzFCLGlCQUFpQixFQUNqQixlQUFXLEVBQ1gsZ0JBQVMsRUFDVCxhQUFhLENBQ2QsQ0FBQztZQUNKLENBQUM7U0FBQTtRQUNEOzs7Ozs7O1dBT0c7UUFDRyxjQUFjLENBQ2xCLEVBQVUsRUFDVixzQkFBK0MsRUFDL0MsT0FBNEI7O2dCQUk1QixNQUFNLGlCQUFpQixHQUFHLE1BQU0seUJBQXlCLENBQUMsY0FBYyxDQUN0RSxFQUFFLEVBQ0Ysc0JBQXNCLEVBQ3RCLE9BQU8sQ0FDUixDQUFDO2dCQUNGLE9BQU8sSUFBQSw4QkFBcUIsRUFDMUIsaUJBQWlCLEVBQ2pCLGVBQVcsRUFDWCxnQkFBUyxFQUNULGFBQWEsQ0FDZCxDQUFDO1lBQ0osQ0FBQztTQUFBO1FBQ0Q7Ozs7OztXQU1HO1FBQ0cscUJBQXFCLENBQ3pCLHNCQUErQyxFQUMvQyxPQUE0Qjs7Z0JBTzVCLE1BQU0saUJBQWlCLEdBQ3JCLE1BQU0seUJBQXlCLENBQUMscUJBQXFCLENBQ25ELHNCQUFzQixFQUN0QixPQUFPLENBQ1IsQ0FBQztnQkFDSixPQUFPLElBQUEsOEJBQXFCLEVBQzFCLGlCQUFpQixFQUNqQixlQUFXLEVBQ1gsZ0JBQVMsRUFDVCxhQUFhLENBQ2QsQ0FBQztZQUNKLENBQUM7U0FBQTtRQUNEOzs7Ozs7V0FNRztRQUNHLGFBQWEsQ0FDakIsc0JBQStDLEVBQy9DLE9BQTRCOztnQkFPNUIsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLHlCQUF5QixDQUFDLGFBQWEsQ0FDckUsc0JBQXNCLEVBQ3RCLE9BQU8sQ0FDUixDQUFDO2dCQUNGLE9BQU8sSUFBQSw4QkFBcUIsRUFDMUIsaUJBQWlCLEVBQ2pCLGVBQVcsRUFDWCxnQkFBUyxFQUNULGFBQWEsQ0FDZCxDQUFDO1lBQ0osQ0FBQztTQUFBO1FBQ0Q7Ozs7OztXQU1HO1FBQ0csVUFBVSxDQUNkLEVBQVUsRUFDVixPQUE0Qjs7Z0JBTzVCLE1BQU0saUJBQWlCLEdBQUcsTUFBTSx5QkFBeUIsQ0FBQyxVQUFVLENBQ2xFLEVBQUUsRUFDRixPQUFPLENBQ1IsQ0FBQztnQkFDRixPQUFPLElBQUEsOEJBQXFCLEVBQzFCLGlCQUFpQixFQUNqQixlQUFXLEVBQ1gsZ0JBQVMsRUFDVCxhQUFhLENBQ2QsQ0FBQztZQUNKLENBQUM7U0FBQTtRQUNEOzs7Ozs7Ozs7Ozs7Ozs7V0FlRztRQUNHLFlBQVksQ0FDaEIsTUFBZSxFQUNmLFlBQXFCLEVBQ3JCLGVBQXdCLEVBQ3hCLElBQWtCLEVBQ2xCLE1BQXdFLEVBQ3hFLElBQWEsRUFDYixFQUFXLEVBQ1gsVUFBbUIsRUFDbkIsU0FBa0IsRUFDbEIsUUFBaUIsRUFDakIsT0FBNEI7O2dCQU81QixNQUFNLGlCQUFpQixHQUFHLE1BQU0seUJBQXlCLENBQUMsWUFBWSxDQUNwRSxNQUFNLEVBQ04sWUFBWSxFQUNaLGVBQWUsRUFDZixJQUFJLEVBQ0osTUFBTSxFQUNOLElBQUksRUFDSixFQUFFLEVBQ0YsVUFBVSxFQUNWLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxDQUNSLENBQUM7Z0JBQ0YsT0FBTyxJQUFBLDhCQUFxQixFQUMxQixpQkFBaUIsRUFDakIsZUFBVyxFQUNYLGdCQUFTLEVBQ1QsYUFBYSxDQUNkLENBQUM7WUFDSixDQUFDO1NBQUE7UUFDRDs7Ozs7OztXQU9HO1FBQ0csYUFBYSxDQUNqQixFQUFVLEVBQ1YscUJBQTZDLEVBQzdDLE9BQTRCOztnQkFPNUIsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLHlCQUF5QixDQUFDLGFBQWEsQ0FDckUsRUFBRSxFQUNGLHFCQUFxQixFQUNyQixPQUFPLENBQ1IsQ0FBQztnQkFDRixPQUFPLElBQUEsOEJBQXFCLEVBQzFCLGlCQUFpQixFQUNqQixlQUFXLEVBQ1gsZ0JBQVMsRUFDVCxhQUFhLENBQ2QsQ0FBQztZQUNKLENBQUM7U0FBQTtLQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUFuT1csUUFBQSxhQUFhLGlCQW1PeEI7QUFFRjs7O0dBR0c7QUFDSSxNQUFNLGtCQUFrQixHQUFHLFVBQ2hDLGFBQTZCLEVBQzdCLFFBQWlCLEVBQ2pCLEtBQXFCO0lBRXJCLE1BQU0sVUFBVSxHQUFHLElBQUEscUJBQWEsRUFBQyxhQUFhLENBQUMsQ0FBQztJQUNoRCxPQUFPO1FBQ0w7Ozs7Ozs7V0FPRztRQUNILGFBQWEsQ0FDWCxFQUFVLEVBQ1YscUJBQTZDLEVBQzdDLE9BQWE7WUFFYixPQUFPLFVBQVU7aUJBQ2QsYUFBYSxDQUFDLEVBQUUsRUFBRSxxQkFBcUIsRUFBRSxPQUFPLENBQUM7aUJBQ2pELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7UUFDRDs7Ozs7OztXQU9HO1FBQ0gsY0FBYyxDQUNaLEVBQVUsRUFDVixzQkFBK0MsRUFDL0MsT0FBYTtZQUViLE9BQU8sVUFBVTtpQkFDZCxjQUFjLENBQUMsRUFBRSxFQUFFLHNCQUFzQixFQUFFLE9BQU8sQ0FBQztpQkFDbkQsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakQsQ0FBQztRQUNEOzs7Ozs7V0FNRztRQUNILHFCQUFxQixDQUNuQixzQkFBK0MsRUFDL0MsT0FBYTtZQUViLE9BQU8sVUFBVTtpQkFDZCxxQkFBcUIsQ0FBQyxzQkFBc0IsRUFBRSxPQUFPLENBQUM7aUJBQ3RELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7UUFDRDs7Ozs7O1dBTUc7UUFDSCxhQUFhLENBQ1gsc0JBQStDLEVBQy9DLE9BQWE7WUFFYixPQUFPLFVBQVU7aUJBQ2QsYUFBYSxDQUFDLHNCQUFzQixFQUFFLE9BQU8sQ0FBQztpQkFDOUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakQsQ0FBQztRQUNEOzs7Ozs7V0FNRztRQUNILFVBQVUsQ0FBQyxFQUFVLEVBQUUsT0FBYTtZQUNsQyxPQUFPLFVBQVU7aUJBQ2QsVUFBVSxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUM7aUJBQ3ZCLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7UUFDRDs7Ozs7Ozs7Ozs7Ozs7O1dBZUc7UUFDSCxZQUFZLENBQ1YsTUFBZSxFQUNmLFlBQXFCLEVBQ3JCLGVBQXdCLEVBQ3hCLElBQWtCLEVBQ2xCLE1BQXdFLEVBQ3hFLElBQWEsRUFDYixFQUFXLEVBQ1gsVUFBbUIsRUFDbkIsU0FBa0IsRUFDbEIsUUFBaUIsRUFDakIsT0FBYTtZQUViLE9BQU8sVUFBVTtpQkFDZCxZQUFZLENBQ1gsTUFBTSxFQUNOLFlBQVksRUFDWixlQUFlLEVBQ2YsSUFBSSxFQUNKLE1BQU0sRUFDTixJQUFJLEVBQ0osRUFBRSxFQUNGLFVBQVUsRUFDVixTQUFTLEVBQ1QsUUFBUSxFQUNSLE9BQU8sQ0FDUjtpQkFDQSxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUNqRCxDQUFDO1FBQ0Q7Ozs7Ozs7V0FPRztRQUNILGFBQWEsQ0FDWCxFQUFVLEVBQ1YscUJBQTZDLEVBQzdDLE9BQWE7WUFFYixPQUFPLFVBQVU7aUJBQ2QsYUFBYSxDQUFDLEVBQUUsRUFBRSxxQkFBcUIsRUFBRSxPQUFPLENBQUM7aUJBQ2pELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBbEpXLFFBQUEsa0JBQWtCLHNCQWtKN0I7QUFFRjs7Ozs7R0FLRztBQUNILE1BQWEsV0FBWSxTQUFRLGNBQU87SUFDdEM7Ozs7Ozs7O09BUUc7SUFDSSxhQUFhLENBQ2xCLEVBQVUsRUFDVixxQkFBNkMsRUFDN0MsT0FBNEI7UUFFNUIsT0FBTyxJQUFBLHFCQUFhLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUNyQyxhQUFhLENBQUMsRUFBRSxFQUFFLHFCQUFxQixFQUFFLE9BQU8sQ0FBQzthQUNqRCxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLGNBQWMsQ0FDbkIsRUFBVSxFQUNWLHNCQUErQyxFQUMvQyxPQUE0QjtRQUU1QixPQUFPLElBQUEscUJBQWEsRUFBQyxJQUFJLENBQUMsYUFBYSxDQUFDO2FBQ3JDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsc0JBQXNCLEVBQUUsT0FBTyxDQUFDO2FBQ25ELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxxQkFBcUIsQ0FDMUIsc0JBQStDLEVBQy9DLE9BQTRCO1FBRTVCLE9BQU8sSUFBQSxxQkFBYSxFQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7YUFDckMscUJBQXFCLENBQUMsc0JBQXNCLEVBQUUsT0FBTyxDQUFDO2FBQ3RELElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSSxhQUFhLENBQ2xCLHNCQUErQyxFQUMvQyxPQUE0QjtRQUU1QixPQUFPLElBQUEscUJBQWEsRUFBQyxJQUFJLENBQUMsYUFBYSxDQUFDO2FBQ3JDLGFBQWEsQ0FBQyxzQkFBc0IsRUFBRSxPQUFPLENBQUM7YUFDOUMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLFVBQVUsQ0FBQyxFQUFVLEVBQUUsT0FBNEI7UUFDeEQsT0FBTyxJQUFBLHFCQUFhLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUNyQyxVQUFVLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQzthQUN2QixJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7OztPQWdCRztJQUNJLFlBQVksQ0FDakIsTUFBZSxFQUNmLFlBQXFCLEVBQ3JCLGVBQXdCLEVBQ3hCLElBQWtCLEVBQ2xCLE1BQXdFLEVBQ3hFLElBQWEsRUFDYixFQUFXLEVBQ1gsVUFBbUIsRUFDbkIsU0FBa0IsRUFDbEIsUUFBaUIsRUFDakIsT0FBNEI7UUFFNUIsT0FBTyxJQUFBLHFCQUFhLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUNyQyxZQUFZLENBQ1gsTUFBTSxFQUNOLFlBQVksRUFDWixlQUFlLEVBQ2YsSUFBSSxFQUNKLE1BQU0sRUFDTixJQUFJLEVBQ0osRUFBRSxFQUNGLFVBQVUsRUFDVixTQUFTLEVBQ1QsUUFBUSxFQUNSLE9BQU8sQ0FDUjthQUNBLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7Ozs7OztPQVFHO0lBQ0ksYUFBYSxDQUNsQixFQUFVLEVBQ1YscUJBQTZDLEVBQzdDLE9BQTRCO1FBRTVCLE9BQU8sSUFBQSxxQkFBYSxFQUFDLElBQUksQ0FBQyxhQUFhLENBQUM7YUFDckMsYUFBYSxDQUFDLEVBQUUsRUFBRSxxQkFBcUIsRUFBRSxPQUFPLENBQUM7YUFDakQsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0NBQ0Y7QUF4SkQsa0NBd0pDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuXG5pbXBvcnQgZ2xvYmFsQXhpb3MsIHtcbiAgQXhpb3NQcm9taXNlLFxuICBBeGlvc0luc3RhbmNlLFxuICBBeGlvc1JlcXVlc3RDb25maWdcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbmZpZ3VyYXRpb25cIjtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHtcbiAgRFVNTVlfQkFTRV9VUkwsXG4gIGFzc2VydFBhcmFtRXhpc3RzLFxuICBzZXRCZWFyZXJBdXRoVG9PYmplY3QsXG4gIHNldFNlYXJjaFBhcmFtcyxcbiAgc2VyaWFsaXplRGF0YUlmTmVlZGVkLFxuICB0b1BhdGhTdHJpbmcsXG4gIGNyZWF0ZVJlcXVlc3RGdW5jdGlvblxufSBmcm9tIFwiLi4vY29tbW9uXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBCQVNFX1BBVEgsXG4gIENPTExFQ1RJT05fRk9STUFUUyxcbiAgUmVxdWVzdEFyZ3MsXG4gIEJhc2VBUEksXG4gIFJlcXVpcmVkRXJyb3Jcbn0gZnJvbSBcIi4uL2Jhc2VcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJhZFJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDYW5jZWxDcmVhdGlvblJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDYW5jZWxQYXltZW50UmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDYXB0dXJlQ3JlYXRpb25SZXF1ZXN0IH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgQ3JlYXRlUGF5bWVudFJlc3BvbnNlIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgQ3JlYXRlV2lyZVBheW1lbnRSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEdldFBheW1lbnRSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IExpc3RQYXltZW50c1Jlc3BvbnNlIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgTW9ja1dpcmVQYXltZW50UmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IE5vdEF1dGhvcml6ZWQgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBOb3RGb3VuZCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IFBheW1lbnRDcmVhdGlvblJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBSZWZ1bmRDcmVhdGlvblJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBSZWZ1bmRQYXltZW50UmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vKipcbiAqIFBheW1lbnRzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBheW1lbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uXG4pIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF5bWVudCB3aWxsIGJlIHZvaWRlZCBpZiBwb3NzaWJsZSBtZWFuaW5nIHRoZSBwYXltZW50IHNvdXJjZSB3aWxsIG5vdCBiZSBjaGFyZ2VkICYgdGhlIHBheW1lbnQgd2lsbCBuZXZlciBzZXR0bGUuIE90aGVyd2lzZSwgdGhlIHBheW1lbnQgd2lsbCBiZSByZWZ1bmRlZCBtZWFuaW5nIHRoZSBwYXltZW50IHNvdXJjZSB3aWxsIGJlIGNoYXJnZWQgJiB0aGUgcGF5bWVudCB3aWxsIGJlIHJlZnVuZGVkIGZyb20gZGVkdWN0aW9ucyBvZiBmdXR1cmUgc2V0dGxlbWVudHMuIE5vdCBhbGwgcGF5bWVudHMgYXJlIGVsaWdpYmxlIHRvIGJlIGNhbmNlbGxlZC4gIEEgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2VzICpub3QqIG1lYW4gdGhlIHBheW1lbnQgaGFzIGJlZW4gY2FuY2VsbGVkOyBpdCBvbmx5IG1lYW5zIHRoZSBjYW5jZWxsYXRpb24gcmVxdWVzdCBpcyBzdWNjZXNzZnVsbHkgc3VibWl0dGVkLlxuICAgICAqIEBzdW1tYXJ5IENhbmNlbCBhIHBheW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAgICogQHBhcmFtIHtDYW5jZWxDcmVhdGlvblJlcXVlc3R9IFtjYW5jZWxDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNhbmNlbFBheW1lbnQ6IGFzeW5jIChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBjYW5jZWxDcmVhdGlvblJlcXVlc3Q/OiBDYW5jZWxDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgIGFzc2VydFBhcmFtRXhpc3RzKFwiY2FuY2VsUGF5bWVudFwiLCBcImlkXCIsIGlkKTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvcGF5bWVudHMve2lkfS9jYW5jZWxgLnJlcGxhY2UoXG4gICAgICAgIGB7JHtcImlkXCJ9fWAsXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoaWQpKVxuICAgICAgKTtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQoXG4gICAgICAgIGNhbmNlbENyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2FybmluZzogUGxlYXNlIGNvbnRhY3QgQ2lyY2xlIHN1cHBvcnQgaWYgeW91IGFyZSBwbGFubmluZyBvbiB1c2luZyB0aGlzIGZlYXR1cmUuICBUaGUgZ2l2ZW4gYW1vdW50IHdpbGwgYmUgY2FwdHVyZWQgZm9yIHRoZSBhdXRob3JpemVkIHBheW1lbnQgaWYgcG9zc2libGUuIElmIG5vIGFtb3VudCBpcyBzcGVjaWZpZWQsIHRoZSBmdWxsIGFtb3VudCB3aWxsIGJlIGNhcHR1cmVkLiBZb3UgY2FuIG9ubHkgY2FwdHVyZSBvbmNlIHBlciBhdXRob3JpemF0aW9uLiAgQSBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXMgKm5vdCogbWVhbiB0aGUgcGF5bWVudCBoYXMgYmVlbiBjYXB0dXJlZC4gSXQgb25seSBtZWFucyB0aGUgY2FwdHVyZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgc3VibWl0dGVkLlxuICAgICAqIEBzdW1tYXJ5IENhcHR1cmUgYSBwYXltZW50IChCRVRBKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge0NhcHR1cmVDcmVhdGlvblJlcXVlc3R9IFtjYXB0dXJlQ3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBjYXB0dXJlUGF5bWVudDogYXN5bmMgKFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIGNhcHR1cmVDcmVhdGlvblJlcXVlc3Q/OiBDYXB0dXJlQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBhc3NlcnRQYXJhbUV4aXN0cyhcImNhcHR1cmVQYXltZW50XCIsIFwiaWRcIiwgaWQpO1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9wYXltZW50cy97aWR9L2NhcHR1cmVgLnJlcGxhY2UoXG4gICAgICAgIGB7JHtcImlkXCJ9fWAsXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoaWQpKVxuICAgICAgKTtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQoXG4gICAgICAgIGNhcHR1cmVDcmVhdGlvblJlcXVlc3QsXG4gICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEluIHRoZSBzYW5kYm94IGVudmlyb25tZW50LCBpbml0aWF0ZSBhIG1vY2sgd2lyZSBwYXltZW50IHRoYXQgbWltaWNzIHRoZSBiZWhhdmlvciBvZiBmdW5kcyBzZW50IHRocm91Z2ggdGhlIGJhbmsgKHdpcmUpIGFjY291bnQgbGlua2VkIHRvIG1hc3RlciB3YWxsZXQuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbW9jayBXaXJlIHBheW1lbnRcbiAgICAgKiBAcGFyYW0ge01vY2tXaXJlUGF5bWVudFJlcXVlc3R9IFttb2NrV2lyZVBheW1lbnRSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBjcmVhdGVNb2NrV2lyZVBheW1lbnQ6IGFzeW5jIChcbiAgICAgIG1vY2tXaXJlUGF5bWVudFJlcXVlc3Q/OiBNb2NrV2lyZVBheW1lbnRSZXF1ZXN0LFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL21vY2tzL3BheW1lbnRzL3dpcmVgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG4gICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge30gYXMgYW55O1xuXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWFyZXJBdXRoIHJlcXVpcmVkXG4gICAgICAvLyBodHRwIGJlYXJlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFxuICAgICAgYXdhaXQgc2V0QmVhcmVyQXV0aFRvT2JqZWN0KGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9IHNlcmlhbGl6ZURhdGFJZk5lZWRlZChcbiAgICAgICAgbW9ja1dpcmVQYXltZW50UmVxdWVzdCxcbiAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtQYXltZW50Q3JlYXRpb25SZXF1ZXN0fSBbcGF5bWVudENyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlUGF5bWVudDogYXN5bmMgKFxuICAgICAgcGF5bWVudENyZWF0aW9uUmVxdWVzdD86IFBheW1lbnRDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvcGF5bWVudHNgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG4gICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge30gYXMgYW55O1xuXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWFyZXJBdXRoIHJlcXVpcmVkXG4gICAgICAvLyBodHRwIGJlYXJlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFxuICAgICAgYXdhaXQgc2V0QmVhcmVyQXV0aFRvT2JqZWN0KGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9IHNlcmlhbGl6ZURhdGFJZk5lZWRlZChcbiAgICAgICAgcGF5bWVudENyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRQYXltZW50OiBhc3luYyAoXG4gICAgICBpZDogc3RyaW5nLFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBhc3NlcnRQYXJhbUV4aXN0cyhcImdldFBheW1lbnRcIiwgXCJpZFwiLCBpZCk7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3BheW1lbnRzL3tpZH1gLnJlcGxhY2UoXG4gICAgICAgIGB7JHtcImlkXCJ9fWAsXG4gICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoaWQpKVxuICAgICAgKTtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG4gICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge30gYXMgYW55O1xuXG4gICAgICAvLyBhdXRoZW50aWNhdGlvbiBiZWFyZXJBdXRoIHJlcXVpcmVkXG4gICAgICAvLyBodHRwIGJlYXJlciBhdXRoZW50aWNhdGlvbiByZXF1aXJlZFxuICAgICAgYXdhaXQgc2V0QmVhcmVyQXV0aFRvT2JqZWN0KGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCBjb25maWd1cmF0aW9uKTtcblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCBwYXltZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlXSBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgZm9yIHRoZSBzb3VyY2UuIEZpbHRlcnMgcmVzdWx0cyB0byBmZXRjaCBvbmx5IHBheW1lbnRzIG1hZGUgZnJvbSB0aGUgcHJvdmRpZGVkIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NldHRsZW1lbnRJZF0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc2V0dGxlbWVudCBpZC4gTWF0Y2hlcyBhbnkgc2V0dGxlbWVudCBpZCBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BheW1lbnRJbnRlbnRJZF0gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bWVudCBpbnRlbnQgaWQuXG4gICAgICogQHBhcmFtIHtTZXQ8J2NhcmQnPn0gW3R5cGVdIFNvdXJjZSBhY2NvdW50IHR5cGUuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW1lbnRzIG1hZGUgZnJvbSBhIHNwZWNpZmllZCBhY2NvdW50IHR5cGUuIE1hdGNoZXMgYW55IHNvdXJjZSB0eXBlIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7J3BlbmRpbmcnIHwgJ2NvbmZpcm1lZCcgfCAncGFpZCcgfCAnZmFpbGVkJyB8ICdhY3Rpb25fcmVxdWlyZWQnfSBbc3RhdHVzXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBzdGF0dXMuIE1hdGNoZXMgYW55IHN0YXR1cyBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUJlZm9yZV0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGVuZCBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYmVmb3JlIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VBZnRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgbGlzdFBheW1lbnRzOiBhc3luYyAoXG4gICAgICBzb3VyY2U/OiBzdHJpbmcsXG4gICAgICBzZXR0bGVtZW50SWQ/OiBzdHJpbmcsXG4gICAgICBwYXltZW50SW50ZW50SWQ/OiBzdHJpbmcsXG4gICAgICB0eXBlPzogU2V0PFwiY2FyZFwiPixcbiAgICAgIHN0YXR1cz86IFwicGVuZGluZ1wiIHwgXCJjb25maXJtZWRcIiB8IFwicGFpZFwiIHwgXCJmYWlsZWRcIiB8IFwiYWN0aW9uX3JlcXVpcmVkXCIsXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvcGF5bWVudHNgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInNvdXJjZVwiXSA9IHNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRsZW1lbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJzZXR0bGVtZW50SWRcIl0gPSBzZXR0bGVtZW50SWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXltZW50SW50ZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wicGF5bWVudEludGVudElkXCJdID0gcGF5bWVudEludGVudElkO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1widHlwZVwiXSA9IEFycmF5LmZyb20odHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wic3RhdHVzXCJdID0gc3RhdHVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJmcm9tXCJdID1cbiAgICAgICAgICAoZnJvbSBhcyBhbnkpIGluc3RhbmNlb2YgRGF0ZSA/IChmcm9tIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IGZyb207XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJ0b1wiXSA9XG4gICAgICAgICAgKHRvIGFzIGFueSkgaW5zdGFuY2VvZiBEYXRlID8gKHRvIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IHRvO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZUJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQmVmb3JlXCJdID0gcGFnZUJlZm9yZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VBZnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQWZ0ZXJcIl0gPSBwYWdlQWZ0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlU2l6ZVwiXSA9IHBhZ2VTaXplO1xuICAgICAgfVxuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBiZSByZWZ1bmRlZCBpZiBwb3NzaWJsZS4gTm90IGFsbCBwYXltZW50cyBhcmUgZWxpZ2libGUgdG8gYmUgY2FuY2VsbGVkLiAgQSBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXMgKm5vdCogbWVhbiB0aGUgcGF5bWVudCBoYXMgYmVlbiByZWZ1bmRlZDsgaXQgb25seSBtZWFucyB0aGUgcmVmdW5kIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZC5cbiAgICAgKiBAc3VtbWFyeSBSZWZ1bmQgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7UmVmdW5kQ3JlYXRpb25SZXF1ZXN0fSBbcmVmdW5kQ3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICByZWZ1bmRQYXltZW50OiBhc3luYyAoXG4gICAgICBpZDogc3RyaW5nLFxuICAgICAgcmVmdW5kQ3JlYXRpb25SZXF1ZXN0PzogUmVmdW5kQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBhc3NlcnRQYXJhbUV4aXN0cyhcInJlZnVuZFBheW1lbnRcIiwgXCJpZFwiLCBpZCk7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3BheW1lbnRzL3tpZH0vcmVmdW5kYC5yZXBsYWNlKFxuICAgICAgICBgeyR7XCJpZFwifX1gLFxuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGlkKSlcbiAgICAgICk7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlcltcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gc2VyaWFsaXplRGF0YUlmTmVlZGVkKFxuICAgICAgICByZWZ1bmRDcmVhdGlvblJlcXVlc3QsXG4gICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFBheW1lbnRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFBheW1lbnRzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9IFBheW1lbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogVGhlIHBheW1lbnQgd2lsbCBiZSB2b2lkZWQgaWYgcG9zc2libGUgbWVhbmluZyB0aGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBub3QgYmUgY2hhcmdlZCAmIHRoZSBwYXltZW50IHdpbGwgbmV2ZXIgc2V0dGxlLiBPdGhlcndpc2UsIHRoZSBwYXltZW50IHdpbGwgYmUgcmVmdW5kZWQgbWVhbmluZyB0aGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBiZSBjaGFyZ2VkICYgdGhlIHBheW1lbnQgd2lsbCBiZSByZWZ1bmRlZCBmcm9tIGRlZHVjdGlvbnMgb2YgZnV0dXJlIHNldHRsZW1lbnRzLiBOb3QgYWxsIHBheW1lbnRzIGFyZSBlbGlnaWJsZSB0byBiZSBjYW5jZWxsZWQuICBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lcyAqbm90KiBtZWFuIHRoZSBwYXltZW50IGhhcyBiZWVuIGNhbmNlbGxlZDsgaXQgb25seSBtZWFucyB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZC5cbiAgICAgKiBAc3VtbWFyeSBDYW5jZWwgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Q2FuY2VsQ3JlYXRpb25SZXF1ZXN0fSBbY2FuY2VsQ3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBjYW5jZWxQYXltZW50KFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIGNhbmNlbENyZWF0aW9uUmVxdWVzdD86IENhbmNlbENyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxDYW5jZWxQYXltZW50UmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY2FuY2VsUGF5bWVudChcbiAgICAgICAgaWQsXG4gICAgICAgIGNhbmNlbENyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2FybmluZzogUGxlYXNlIGNvbnRhY3QgQ2lyY2xlIHN1cHBvcnQgaWYgeW91IGFyZSBwbGFubmluZyBvbiB1c2luZyB0aGlzIGZlYXR1cmUuICBUaGUgZ2l2ZW4gYW1vdW50IHdpbGwgYmUgY2FwdHVyZWQgZm9yIHRoZSBhdXRob3JpemVkIHBheW1lbnQgaWYgcG9zc2libGUuIElmIG5vIGFtb3VudCBpcyBzcGVjaWZpZWQsIHRoZSBmdWxsIGFtb3VudCB3aWxsIGJlIGNhcHR1cmVkLiBZb3UgY2FuIG9ubHkgY2FwdHVyZSBvbmNlIHBlciBhdXRob3JpemF0aW9uLiAgQSBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXMgKm5vdCogbWVhbiB0aGUgcGF5bWVudCBoYXMgYmVlbiBjYXB0dXJlZC4gSXQgb25seSBtZWFucyB0aGUgY2FwdHVyZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgc3VibWl0dGVkLlxuICAgICAqIEBzdW1tYXJ5IENhcHR1cmUgYSBwYXltZW50IChCRVRBKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge0NhcHR1cmVDcmVhdGlvblJlcXVlc3R9IFtjYXB0dXJlQ3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBjYXB0dXJlUGF5bWVudChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBjYXB0dXJlQ3JlYXRpb25SZXF1ZXN0PzogQ2FwdHVyZUNyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKGF4aW9zPzogQXhpb3NJbnN0YW5jZSwgYmFzZVBhdGg/OiBzdHJpbmcpID0+IEF4aW9zUHJvbWlzZTx2b2lkPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNhcHR1cmVQYXltZW50KFxuICAgICAgICBpZCxcbiAgICAgICAgY2FwdHVyZUNyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQsIGluaXRpYXRlIGEgbW9jayB3aXJlIHBheW1lbnQgdGhhdCBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mIGZ1bmRzIHNlbnQgdGhyb3VnaCB0aGUgYmFuayAod2lyZSkgYWNjb3VudCBsaW5rZWQgdG8gbWFzdGVyIHdhbGxldC5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBtb2NrIFdpcmUgcGF5bWVudFxuICAgICAqIEBwYXJhbSB7TW9ja1dpcmVQYXltZW50UmVxdWVzdH0gW21vY2tXaXJlUGF5bWVudFJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZU1vY2tXaXJlUGF5bWVudChcbiAgICAgIG1vY2tXaXJlUGF5bWVudFJlcXVlc3Q/OiBNb2NrV2lyZVBheW1lbnRSZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICAgICk6IFByb21pc2U8XG4gICAgICAoXG4gICAgICAgIGF4aW9zPzogQXhpb3NJbnN0YW5jZSxcbiAgICAgICAgYmFzZVBhdGg/OiBzdHJpbmdcbiAgICAgICkgPT4gQXhpb3NQcm9taXNlPENyZWF0ZVdpcmVQYXltZW50UmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9XG4gICAgICAgIGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlTW9ja1dpcmVQYXltZW50KFxuICAgICAgICAgIG1vY2tXaXJlUGF5bWVudFJlcXVlc3QsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHBheW1lbnRcbiAgICAgKiBAcGFyYW0ge1BheW1lbnRDcmVhdGlvblJlcXVlc3R9IFtwYXltZW50Q3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQYXltZW50KFxuICAgICAgcGF5bWVudENyZWF0aW9uUmVxdWVzdD86IFBheW1lbnRDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8Q3JlYXRlUGF5bWVudFJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVBheW1lbnQoXG4gICAgICAgIHBheW1lbnRDcmVhdGlvblJlcXVlc3QsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgcGF5bWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGF5bWVudChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8R2V0UGF5bWVudFJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFBheW1lbnQoXG4gICAgICAgIGlkLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW1lbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VdIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBmb3IgdGhlIHNvdXJjZS4gRmlsdGVycyByZXN1bHRzIHRvIGZldGNoIG9ubHkgcGF5bWVudHMgbWFkZSBmcm9tIHRoZSBwcm92ZGlkZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2V0dGxlbWVudElkXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBzZXR0bGVtZW50IGlkLiBNYXRjaGVzIGFueSBzZXR0bGVtZW50IGlkIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bWVudEludGVudElkXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBwYXltZW50IGludGVudCBpZC5cbiAgICAgKiBAcGFyYW0ge1NldDwnY2FyZCc+fSBbdHlwZV0gU291cmNlIGFjY291bnQgdHlwZS4gRmlsdGVycyB0aGUgcmVzdWx0cyB0byBmZXRjaCBhbGwgcGF5bWVudHMgbWFkZSBmcm9tIGEgc3BlY2lmaWVkIGFjY291bnQgdHlwZS4gTWF0Y2hlcyBhbnkgc291cmNlIHR5cGUgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHsncGVuZGluZycgfCAnY29uZmlybWVkJyB8ICdwYWlkJyB8ICdmYWlsZWQnIHwgJ2FjdGlvbl9yZXF1aXJlZCd9IFtzdGF0dXNdIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXR1cy4gTWF0Y2hlcyBhbnkgc3RhdHVzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0UGF5bWVudHMoXG4gICAgICBzb3VyY2U/OiBzdHJpbmcsXG4gICAgICBzZXR0bGVtZW50SWQ/OiBzdHJpbmcsXG4gICAgICBwYXltZW50SW50ZW50SWQ/OiBzdHJpbmcsXG4gICAgICB0eXBlPzogU2V0PFwiY2FyZFwiPixcbiAgICAgIHN0YXR1cz86IFwicGVuZGluZ1wiIHwgXCJjb25maXJtZWRcIiB8IFwicGFpZFwiIHwgXCJmYWlsZWRcIiB8IFwiYWN0aW9uX3JlcXVpcmVkXCIsXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8TGlzdFBheW1lbnRzUmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFBheW1lbnRzKFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNldHRsZW1lbnRJZCxcbiAgICAgICAgcGF5bWVudEludGVudElkLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBwYWdlQmVmb3JlLFxuICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgIHBhZ2VTaXplLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBiZSByZWZ1bmRlZCBpZiBwb3NzaWJsZS4gTm90IGFsbCBwYXltZW50cyBhcmUgZWxpZ2libGUgdG8gYmUgY2FuY2VsbGVkLiAgQSBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXMgKm5vdCogbWVhbiB0aGUgcGF5bWVudCBoYXMgYmVlbiByZWZ1bmRlZDsgaXQgb25seSBtZWFucyB0aGUgcmVmdW5kIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZC5cbiAgICAgKiBAc3VtbWFyeSBSZWZ1bmQgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7UmVmdW5kQ3JlYXRpb25SZXF1ZXN0fSBbcmVmdW5kQ3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyByZWZ1bmRQYXltZW50KFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIHJlZnVuZENyZWF0aW9uUmVxdWVzdD86IFJlZnVuZENyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxSZWZ1bmRQYXltZW50UmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmVmdW5kUGF5bWVudChcbiAgICAgICAgaWQsXG4gICAgICAgIHJlZnVuZENyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogUGF5bWVudHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgUGF5bWVudHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKFxuICBjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvbixcbiAgYmFzZVBhdGg/OiBzdHJpbmcsXG4gIGF4aW9zPzogQXhpb3NJbnN0YW5jZVxuKSB7XG4gIGNvbnN0IGxvY2FsVmFyRnAgPSBQYXltZW50c0FwaUZwKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXltZW50IHdpbGwgYmUgdm9pZGVkIGlmIHBvc3NpYmxlIG1lYW5pbmcgdGhlIHBheW1lbnQgc291cmNlIHdpbGwgbm90IGJlIGNoYXJnZWQgJiB0aGUgcGF5bWVudCB3aWxsIG5ldmVyIHNldHRsZS4gT3RoZXJ3aXNlLCB0aGUgcGF5bWVudCB3aWxsIGJlIHJlZnVuZGVkIG1lYW5pbmcgdGhlIHBheW1lbnQgc291cmNlIHdpbGwgYmUgY2hhcmdlZCAmIHRoZSBwYXltZW50IHdpbGwgYmUgcmVmdW5kZWQgZnJvbSBkZWR1Y3Rpb25zIG9mIGZ1dHVyZSBzZXR0bGVtZW50cy4gTm90IGFsbCBwYXltZW50cyBhcmUgZWxpZ2libGUgdG8gYmUgY2FuY2VsbGVkLiAgQSBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXMgKm5vdCogbWVhbiB0aGUgcGF5bWVudCBoYXMgYmVlbiBjYW5jZWxsZWQ7IGl0IG9ubHkgbWVhbnMgdGhlIGNhbmNlbGxhdGlvbiByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuXG4gICAgICogQHN1bW1hcnkgQ2FuY2VsIGEgcGF5bWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge0NhbmNlbENyZWF0aW9uUmVxdWVzdH0gW2NhbmNlbENyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY2FuY2VsUGF5bWVudChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBjYW5jZWxDcmVhdGlvblJlcXVlc3Q/OiBDYW5jZWxDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPENhbmNlbFBheW1lbnRSZXNwb25zZT4ge1xuICAgICAgcmV0dXJuIGxvY2FsVmFyRnBcbiAgICAgICAgLmNhbmNlbFBheW1lbnQoaWQsIGNhbmNlbENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBXYXJuaW5nOiBQbGVhc2UgY29udGFjdCBDaXJjbGUgc3VwcG9ydCBpZiB5b3UgYXJlIHBsYW5uaW5nIG9uIHVzaW5nIHRoaXMgZmVhdHVyZS4gIFRoZSBnaXZlbiBhbW91bnQgd2lsbCBiZSBjYXB0dXJlZCBmb3IgdGhlIGF1dGhvcml6ZWQgcGF5bWVudCBpZiBwb3NzaWJsZS4gSWYgbm8gYW1vdW50IGlzIHNwZWNpZmllZCwgdGhlIGZ1bGwgYW1vdW50IHdpbGwgYmUgY2FwdHVyZWQuIFlvdSBjYW4gb25seSBjYXB0dXJlIG9uY2UgcGVyIGF1dGhvcml6YXRpb24uICBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lcyAqbm90KiBtZWFuIHRoZSBwYXltZW50IGhhcyBiZWVuIGNhcHR1cmVkLiBJdCBvbmx5IG1lYW5zIHRoZSBjYXB0dXJlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuXG4gICAgICogQHN1bW1hcnkgQ2FwdHVyZSBhIHBheW1lbnQgKEJFVEEpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Q2FwdHVyZUNyZWF0aW9uUmVxdWVzdH0gW2NhcHR1cmVDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNhcHR1cmVQYXltZW50KFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIGNhcHR1cmVDcmVhdGlvblJlcXVlc3Q/OiBDYXB0dXJlQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTx2b2lkPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuY2FwdHVyZVBheW1lbnQoaWQsIGNhcHR1cmVDcmVhdGlvblJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogSW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQsIGluaXRpYXRlIGEgbW9jayB3aXJlIHBheW1lbnQgdGhhdCBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mIGZ1bmRzIHNlbnQgdGhyb3VnaCB0aGUgYmFuayAod2lyZSkgYWNjb3VudCBsaW5rZWQgdG8gbWFzdGVyIHdhbGxldC5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBtb2NrIFdpcmUgcGF5bWVudFxuICAgICAqIEBwYXJhbSB7TW9ja1dpcmVQYXltZW50UmVxdWVzdH0gW21vY2tXaXJlUGF5bWVudFJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZU1vY2tXaXJlUGF5bWVudChcbiAgICAgIG1vY2tXaXJlUGF5bWVudFJlcXVlc3Q/OiBNb2NrV2lyZVBheW1lbnRSZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxDcmVhdGVXaXJlUGF5bWVudFJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuY3JlYXRlTW9ja1dpcmVQYXltZW50KG1vY2tXaXJlUGF5bWVudFJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtQYXltZW50Q3JlYXRpb25SZXF1ZXN0fSBbcGF5bWVudENyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlUGF5bWVudChcbiAgICAgIHBheW1lbnRDcmVhdGlvblJlcXVlc3Q/OiBQYXltZW50Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxDcmVhdGVQYXltZW50UmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5jcmVhdGVQYXltZW50KHBheW1lbnRDcmVhdGlvblJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSBwYXltZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRQYXltZW50KGlkOiBzdHJpbmcsIG9wdGlvbnM/OiBhbnkpOiBBeGlvc1Byb21pc2U8R2V0UGF5bWVudFJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuZ2V0UGF5bWVudChpZCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW1lbnRzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VdIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBmb3IgdGhlIHNvdXJjZS4gRmlsdGVycyByZXN1bHRzIHRvIGZldGNoIG9ubHkgcGF5bWVudHMgbWFkZSBmcm9tIHRoZSBwcm92ZGlkZWQgc291cmNlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2V0dGxlbWVudElkXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBzZXR0bGVtZW50IGlkLiBNYXRjaGVzIGFueSBzZXR0bGVtZW50IGlkIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bWVudEludGVudElkXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBwYXltZW50IGludGVudCBpZC5cbiAgICAgKiBAcGFyYW0ge1NldDwnY2FyZCc+fSBbdHlwZV0gU291cmNlIGFjY291bnQgdHlwZS4gRmlsdGVycyB0aGUgcmVzdWx0cyB0byBmZXRjaCBhbGwgcGF5bWVudHMgbWFkZSBmcm9tIGEgc3BlY2lmaWVkIGFjY291bnQgdHlwZS4gTWF0Y2hlcyBhbnkgc291cmNlIHR5cGUgaWYgdW5zcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHsncGVuZGluZycgfCAnY29uZmlybWVkJyB8ICdwYWlkJyB8ICdmYWlsZWQnIHwgJ2FjdGlvbl9yZXF1aXJlZCd9IFtzdGF0dXNdIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIHN0YXR1cy4gTWF0Y2hlcyBhbnkgc3RhdHVzIGlmIHVuc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0UGF5bWVudHMoXG4gICAgICBzb3VyY2U/OiBzdHJpbmcsXG4gICAgICBzZXR0bGVtZW50SWQ/OiBzdHJpbmcsXG4gICAgICBwYXltZW50SW50ZW50SWQ/OiBzdHJpbmcsXG4gICAgICB0eXBlPzogU2V0PFwiY2FyZFwiPixcbiAgICAgIHN0YXR1cz86IFwicGVuZGluZ1wiIHwgXCJjb25maXJtZWRcIiB8IFwicGFpZFwiIHwgXCJmYWlsZWRcIiB8IFwiYWN0aW9uX3JlcXVpcmVkXCIsXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPExpc3RQYXltZW50c1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAubGlzdFBheW1lbnRzKFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICBzZXR0bGVtZW50SWQsXG4gICAgICAgICAgcGF5bWVudEludGVudElkLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIHBheW1lbnQgc291cmNlIHdpbGwgYmUgcmVmdW5kZWQgaWYgcG9zc2libGUuIE5vdCBhbGwgcGF5bWVudHMgYXJlIGVsaWdpYmxlIHRvIGJlIGNhbmNlbGxlZC4gIEEgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2VzICpub3QqIG1lYW4gdGhlIHBheW1lbnQgaGFzIGJlZW4gcmVmdW5kZWQ7IGl0IG9ubHkgbWVhbnMgdGhlIHJlZnVuZCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuXG4gICAgICogQHN1bW1hcnkgUmVmdW5kIGEgcGF5bWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge1JlZnVuZENyZWF0aW9uUmVxdWVzdH0gW3JlZnVuZENyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgcmVmdW5kUGF5bWVudChcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICByZWZ1bmRDcmVhdGlvblJlcXVlc3Q/OiBSZWZ1bmRDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPFJlZnVuZFBheW1lbnRSZXNwb25zZT4ge1xuICAgICAgcmV0dXJuIGxvY2FsVmFyRnBcbiAgICAgICAgLnJlZnVuZFBheW1lbnQoaWQsIHJlZnVuZENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQYXltZW50c0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBQYXltZW50c0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmV4cG9ydCBjbGFzcyBQYXltZW50c0FwaSBleHRlbmRzIEJhc2VBUEkge1xuICAvKipcbiAgICogVGhlIHBheW1lbnQgd2lsbCBiZSB2b2lkZWQgaWYgcG9zc2libGUgbWVhbmluZyB0aGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBub3QgYmUgY2hhcmdlZCAmIHRoZSBwYXltZW50IHdpbGwgbmV2ZXIgc2V0dGxlLiBPdGhlcndpc2UsIHRoZSBwYXltZW50IHdpbGwgYmUgcmVmdW5kZWQgbWVhbmluZyB0aGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBiZSBjaGFyZ2VkICYgdGhlIHBheW1lbnQgd2lsbCBiZSByZWZ1bmRlZCBmcm9tIGRlZHVjdGlvbnMgb2YgZnV0dXJlIHNldHRsZW1lbnRzLiBOb3QgYWxsIHBheW1lbnRzIGFyZSBlbGlnaWJsZSB0byBiZSBjYW5jZWxsZWQuICBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lcyAqbm90KiBtZWFuIHRoZSBwYXltZW50IGhhcyBiZWVuIGNhbmNlbGxlZDsgaXQgb25seSBtZWFucyB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZC5cbiAgICogQHN1bW1hcnkgQ2FuY2VsIGEgcGF5bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7Q2FuY2VsQ3JlYXRpb25SZXF1ZXN0fSBbY2FuY2VsQ3JlYXRpb25SZXF1ZXN0XVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUGF5bWVudHNBcGlcbiAgICovXG4gIHB1YmxpYyBjYW5jZWxQYXltZW50KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgY2FuY2VsQ3JlYXRpb25SZXF1ZXN0PzogQ2FuY2VsQ3JlYXRpb25SZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIFBheW1lbnRzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmNhbmNlbFBheW1lbnQoaWQsIGNhbmNlbENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJuaW5nOiBQbGVhc2UgY29udGFjdCBDaXJjbGUgc3VwcG9ydCBpZiB5b3UgYXJlIHBsYW5uaW5nIG9uIHVzaW5nIHRoaXMgZmVhdHVyZS4gIFRoZSBnaXZlbiBhbW91bnQgd2lsbCBiZSBjYXB0dXJlZCBmb3IgdGhlIGF1dGhvcml6ZWQgcGF5bWVudCBpZiBwb3NzaWJsZS4gSWYgbm8gYW1vdW50IGlzIHNwZWNpZmllZCwgdGhlIGZ1bGwgYW1vdW50IHdpbGwgYmUgY2FwdHVyZWQuIFlvdSBjYW4gb25seSBjYXB0dXJlIG9uY2UgcGVyIGF1dGhvcml6YXRpb24uICBBIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZG9lcyAqbm90KiBtZWFuIHRoZSBwYXltZW50IGhhcyBiZWVuIGNhcHR1cmVkLiBJdCBvbmx5IG1lYW5zIHRoZSBjYXB0dXJlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBzdWJtaXR0ZWQuXG4gICAqIEBzdW1tYXJ5IENhcHR1cmUgYSBwYXltZW50IChCRVRBKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7Q2FwdHVyZUNyZWF0aW9uUmVxdWVzdH0gW2NhcHR1cmVDcmVhdGlvblJlcXVlc3RdXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBQYXltZW50c0FwaVxuICAgKi9cbiAgcHVibGljIGNhcHR1cmVQYXltZW50KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgY2FwdHVyZUNyZWF0aW9uUmVxdWVzdD86IENhcHR1cmVDcmVhdGlvblJlcXVlc3QsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gUGF5bWVudHNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuY2FwdHVyZVBheW1lbnQoaWQsIGNhcHR1cmVDcmVhdGlvblJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICogSW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQsIGluaXRpYXRlIGEgbW9jayB3aXJlIHBheW1lbnQgdGhhdCBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mIGZ1bmRzIHNlbnQgdGhyb3VnaCB0aGUgYmFuayAod2lyZSkgYWNjb3VudCBsaW5rZWQgdG8gbWFzdGVyIHdhbGxldC5cbiAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbW9jayBXaXJlIHBheW1lbnRcbiAgICogQHBhcmFtIHtNb2NrV2lyZVBheW1lbnRSZXF1ZXN0fSBbbW9ja1dpcmVQYXltZW50UmVxdWVzdF1cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFBheW1lbnRzQXBpXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlTW9ja1dpcmVQYXltZW50KFxuICAgIG1vY2tXaXJlUGF5bWVudFJlcXVlc3Q/OiBNb2NrV2lyZVBheW1lbnRSZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIFBheW1lbnRzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmNyZWF0ZU1vY2tXaXJlUGF5bWVudChtb2NrV2lyZVBheW1lbnRSZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHBheW1lbnRcbiAgICogQHBhcmFtIHtQYXltZW50Q3JlYXRpb25SZXF1ZXN0fSBbcGF5bWVudENyZWF0aW9uUmVxdWVzdF1cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFBheW1lbnRzQXBpXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlUGF5bWVudChcbiAgICBwYXltZW50Q3JlYXRpb25SZXF1ZXN0PzogUGF5bWVudENyZWF0aW9uUmVxdWVzdCxcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBQYXltZW50c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5jcmVhdGVQYXltZW50KHBheW1lbnRDcmVhdGlvblJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHN1bW1hcnkgR2V0IGEgcGF5bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBQYXltZW50c0FwaVxuICAgKi9cbiAgcHVibGljIGdldFBheW1lbnQoaWQ6IHN0cmluZywgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZykge1xuICAgIHJldHVybiBQYXltZW50c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5nZXRQYXltZW50KGlkLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzdW1tYXJ5IExpc3QgYWxsIHBheW1lbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlXSBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgZm9yIHRoZSBzb3VyY2UuIEZpbHRlcnMgcmVzdWx0cyB0byBmZXRjaCBvbmx5IHBheW1lbnRzIG1hZGUgZnJvbSB0aGUgcHJvdmRpZGVkIHNvdXJjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXR0bGVtZW50SWRdIFF1ZXJpZXMgaXRlbXMgd2l0aCB0aGUgc3BlY2lmaWVkIHNldHRsZW1lbnQgaWQuIE1hdGNoZXMgYW55IHNldHRsZW1lbnQgaWQgaWYgdW5zcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF5bWVudEludGVudElkXSBRdWVyaWVzIGl0ZW1zIHdpdGggdGhlIHNwZWNpZmllZCBwYXltZW50IGludGVudCBpZC5cbiAgICogQHBhcmFtIHtTZXQ8J2NhcmQnPn0gW3R5cGVdIFNvdXJjZSBhY2NvdW50IHR5cGUuIEZpbHRlcnMgdGhlIHJlc3VsdHMgdG8gZmV0Y2ggYWxsIHBheW1lbnRzIG1hZGUgZnJvbSBhIHNwZWNpZmllZCBhY2NvdW50IHR5cGUuIE1hdGNoZXMgYW55IHNvdXJjZSB0eXBlIGlmIHVuc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0geydwZW5kaW5nJyB8ICdjb25maXJtZWQnIHwgJ3BhaWQnIHwgJ2ZhaWxlZCcgfCAnYWN0aW9uX3JlcXVpcmVkJ30gW3N0YXR1c10gUXVlcmllcyBpdGVtcyB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhdHVzLiBNYXRjaGVzIGFueSBzdGF0dXMgaWYgdW5zcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFBheW1lbnRzQXBpXG4gICAqL1xuICBwdWJsaWMgbGlzdFBheW1lbnRzKFxuICAgIHNvdXJjZT86IHN0cmluZyxcbiAgICBzZXR0bGVtZW50SWQ/OiBzdHJpbmcsXG4gICAgcGF5bWVudEludGVudElkPzogc3RyaW5nLFxuICAgIHR5cGU/OiBTZXQ8XCJjYXJkXCI+LFxuICAgIHN0YXR1cz86IFwicGVuZGluZ1wiIHwgXCJjb25maXJtZWRcIiB8IFwicGFpZFwiIHwgXCJmYWlsZWRcIiB8IFwiYWN0aW9uX3JlcXVpcmVkXCIsXG4gICAgZnJvbT86IHN0cmluZyxcbiAgICB0bz86IHN0cmluZyxcbiAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICBwYWdlU2l6ZT86IG51bWJlcixcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBQYXltZW50c0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5saXN0UGF5bWVudHMoXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc2V0dGxlbWVudElkLFxuICAgICAgICBwYXltZW50SW50ZW50SWQsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgICAgIHBhZ2VCZWZvcmUsXG4gICAgICAgIHBhZ2VBZnRlcixcbiAgICAgICAgcGFnZVNpemUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgcGF5bWVudCBzb3VyY2Ugd2lsbCBiZSByZWZ1bmRlZCBpZiBwb3NzaWJsZS4gTm90IGFsbCBwYXltZW50cyBhcmUgZWxpZ2libGUgdG8gYmUgY2FuY2VsbGVkLiAgQSBzdWNjZXNzZnVsIHJlc3BvbnNlIGRvZXMgKm5vdCogbWVhbiB0aGUgcGF5bWVudCBoYXMgYmVlbiByZWZ1bmRlZDsgaXQgb25seSBtZWFucyB0aGUgcmVmdW5kIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bGx5IHN1Ym1pdHRlZC5cbiAgICogQHN1bW1hcnkgUmVmdW5kIGEgcGF5bWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7UmVmdW5kQ3JlYXRpb25SZXF1ZXN0fSBbcmVmdW5kQ3JlYXRpb25SZXF1ZXN0XVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUGF5bWVudHNBcGlcbiAgICovXG4gIHB1YmxpYyByZWZ1bmRQYXltZW50KFxuICAgIGlkOiBzdHJpbmcsXG4gICAgcmVmdW5kQ3JlYXRpb25SZXF1ZXN0PzogUmVmdW5kQ3JlYXRpb25SZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIFBheW1lbnRzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLnJlZnVuZFBheW1lbnQoaWQsIHJlZnVuZENyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxufVxuIl19