"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * TransfersApi - axios parameter creator
 * @export
 */
const TransfersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * A transfer can be made from an existing business account to a blockchain location.
         * @summary Create a transfer
         * @param {BusinessTransferCreationRequest} [businessTransferCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessTransfer: (businessTransferCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(businessTransferCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
         * @summary Create a transfer
         * @param {TransferCreationRequest} [transferCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer: (transferCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(transferCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessTransfer: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("getBusinessTransfer", "id", id);
            const localVarPath = `/v1/businessAccount/transfers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer: (id, returnIdentities, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("getTransfer", "id", id);
            const localVarPath = `/v1/transfers/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (returnIdentities !== undefined) {
                localVarQueryParameter["returnIdentities"] = returnIdentities;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessTransfers: (from, to, pageBefore, pageAfter, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/businessAccount/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (from !== undefined) {
                localVarQueryParameter["from"] =
                    from instanceof Date ? from.toISOString() : from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] =
                    to instanceof Date ? to.toISOString() : to;
            }
            if (pageBefore !== undefined) {
                localVarQueryParameter["pageBefore"] = pageBefore;
            }
            if (pageAfter !== undefined) {
                localVarQueryParameter["pageAfter"] = pageAfter;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["pageSize"] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
         * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
         * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers: (walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (walletId !== undefined) {
                localVarQueryParameter["walletId"] = walletId;
            }
            if (sourceWalletId !== undefined) {
                localVarQueryParameter["sourceWalletId"] = sourceWalletId;
            }
            if (destinationWalletId !== undefined) {
                localVarQueryParameter["destinationWalletId"] = destinationWalletId;
            }
            if (returnIdentities !== undefined) {
                localVarQueryParameter["returnIdentities"] = returnIdentities;
            }
            if (from !== undefined) {
                localVarQueryParameter["from"] =
                    from instanceof Date ? from.toISOString() : from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] =
                    to instanceof Date ? to.toISOString() : to;
            }
            if (pageBefore !== undefined) {
                localVarQueryParameter["pageBefore"] = pageBefore;
            }
            if (pageAfter !== undefined) {
                localVarQueryParameter["pageAfter"] = pageAfter;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter["pageSize"] = pageSize;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;
/**
 * TransfersApi - functional programming interface
 * @export
 */
const TransfersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);
    return {
        /**
         * A transfer can be made from an existing business account to a blockchain location.
         * @summary Create a transfer
         * @param {BusinessTransferCreationRequest} [businessTransferCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessTransfer(businessTransferCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBusinessTransfer(businessTransferCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
         * @summary Create a transfer
         * @param {TransferCreationRequest} [transferCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransfer(transferCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessTransfer(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBusinessTransfer(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(id, returnIdentities, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransfer(id, returnIdentities, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessTransfers(from, to, pageBefore, pageAfter, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listBusinessTransfers(from, to, pageBefore, pageAfter, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
         * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
         * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.TransfersApiFp = TransfersApiFp;
/**
 * TransfersApi - factory interface
 * @export
 */
const TransfersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TransfersApiFp)(configuration);
    return {
        /**
         * A transfer can be made from an existing business account to a blockchain location.
         * @summary Create a transfer
         * @param {BusinessTransferCreationRequest} [businessTransferCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBusinessTransfer(businessTransferCreationRequest, options) {
            return localVarFp
                .createBusinessTransfer(businessTransferCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
         * @summary Create a transfer
         * @param {TransferCreationRequest} [transferCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransfer(transferCreationRequest, options) {
            return localVarFp
                .createTransfer(transferCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessTransfer(id, options) {
            return localVarFp
                .getBusinessTransfer(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a transfer
         * @param {string} id Universally unique identifier (UUID v4) of a resource.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransfer(id, returnIdentities, options) {
            return localVarFp
                .getTransfer(id, returnIdentities, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBusinessTransfers(from, to, pageBefore, pageAfter, pageSize, options) {
            return localVarFp
                .listBusinessTransfers(from, to, pageBefore, pageAfter, pageSize, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
         * @summary List all transfers
         * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
         * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
         * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
         * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
         * @param {string} [from] Queries items created since the specified date-time (inclusive).
         * @param {string} [to] Queries items created before the specified date-time (inclusive).
         * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
         * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
         * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options) {
            return localVarFp
                .listTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.TransfersApiFactory = TransfersApiFactory;
/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
class TransfersApi extends base_1.BaseAPI {
    /**
     * A transfer can be made from an existing business account to a blockchain location.
     * @summary Create a transfer
     * @param {BusinessTransferCreationRequest} [businessTransferCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createBusinessTransfer(businessTransferCreationRequest, options) {
        return (0, exports.TransfersApiFp)(this.configuration)
            .createBusinessTransfer(businessTransferCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * A transfer can be made from an existing funded wallet to a blockchain address or another wallet.
     * @summary Create a transfer
     * @param {TransferCreationRequest} [transferCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    createTransfer(transferCreationRequest, options) {
        return (0, exports.TransfersApiFp)(this.configuration)
            .createTransfer(transferCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a transfer
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getBusinessTransfer(id, options) {
        return (0, exports.TransfersApiFp)(this.configuration)
            .getBusinessTransfer(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a transfer
     * @param {string} id Universally unique identifier (UUID v4) of a resource.
     * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    getTransfer(id, returnIdentities, options) {
        return (0, exports.TransfersApiFp)(this.configuration)
            .getTransfer(id, returnIdentities, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches for transfers from your business account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
     * @summary List all transfers
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    listBusinessTransfers(from, to, pageBefore, pageAfter, pageSize, options) {
        return (0, exports.TransfersApiFp)(this.configuration)
            .listBusinessTransfers(from, to, pageBefore, pageAfter, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches for transfers involving the provided wallets. If no wallet ids are provided, searches all wallets associated with your Circle API account. If the date parameters are omitted, returns the most recent transfers. This endpoint returns up to 50 transfers in descending chronological order or pageSize, if provided.
     * @summary List all transfers
     * @param {string} [walletId] Unique identifier for the source or destination wallet of transfers, if any. May not be used in conjunction with destinationWalletId or sourceWalletId. Useful for fetching all transfers related to a wallet.
     * @param {string} [sourceWalletId] Unique identifier for the source wallet of transfers, if any.
     * @param {string} [destinationWalletId] Unique identifier for the destination wallet of transfers, if any.
     * @param {boolean} [returnIdentities] Specify if you would like to see identities in the response. Restricts maximum returned items to 5. By default returnIdentities is false, resulting in the response not returning &#x60;data.source.identities&#x60;.
     * @param {string} [from] Queries items created since the specified date-time (inclusive).
     * @param {string} [to] Queries items created before the specified date-time (inclusive).
     * @param {string} [pageBefore] A collection ID value used for pagination.  It marks the exclusive end of a page. When provided, the collection resource will return the next &#x60;n&#x60; items before the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageAfter.
     * @param {string} [pageAfter] A collection ID value used for pagination.  It marks the exclusive begin of a page. When provided, the collection resource will return the next &#x60;n&#x60; items after the id, with &#x60;n&#x60; being specified by &#x60;pageSize&#x60;.  The items will be returned in the natural order of the collection.  The resource will return the first page if neither &#x60;pageAfter&#x60; nor &#x60;pageBefore&#x60; are specified.  SHOULD NOT be used in conjuction with pageBefore.
     * @param {number} [pageSize] Limits the number of items to be returned.  Some collections have a strict upper bound that will disregard this value. In case the specified value is higher than the allowed limit, the collection limit will be used.  If avoided, the collection will determine the page size itself.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    listTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options) {
        return (0, exports.TransfersApiFp)(this.configuration)
            .listTransfers(walletId, sourceWalletId, destinationWalletId, returnIdentities, from, to, pageBefore, pageAfter, pageSize, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.TransfersApi = TransfersApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmZXJzLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9nZW5lcmF0ZWQvYXBpcy90cmFuc2ZlcnMtYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCOzs7O0dBSUc7Ozs7Ozs7Ozs7Ozs7OztBQUVILGtEQUllO0FBRWYseURBQXlEO0FBQ3pELGFBQWE7QUFDYixzQ0FRbUI7QUFDbkIsYUFBYTtBQUNiLGtDQU1pQjtBQW1CakI7OztHQUdHO0FBQ0ksTUFBTSw2QkFBNkIsR0FBRyxVQUMzQyxhQUE2QjtJQUU3QixPQUFPO1FBQ0w7Ozs7OztXQU1HO1FBQ0gsc0JBQXNCLEVBQUUsQ0FDdEIsK0JBQWlFLEVBQ2pFLFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLCtCQUErQixDQUFDO1lBQ3JELG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsTUFBTSxJQUNYLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDO1lBRTdELElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJ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LEVBQ1QsUUFBUSxFQUNSLE9BQU8sQ0FDUjthQUNBLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztDQUNGO0FBeElELG9DQXdJQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cblxuaW1wb3J0IGdsb2JhbEF4aW9zLCB7XG4gIEF4aW9zUHJvbWlzZSxcbiAgQXhpb3NJbnN0YW5jZSxcbiAgQXhpb3NSZXF1ZXN0Q29uZmlnXG59IGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IHsgQ29uZmlndXJhdGlvbiB9IGZyb20gXCIuLi9jb25maWd1cmF0aW9uXCI7XG4vLyBTb21lIGltcG9ydHMgbm90IHVzZWQgZGVwZW5kaW5nIG9uIHRlbXBsYXRlIGNvbmRpdGlvbnNcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7XG4gIERVTU1ZX0JBU0VfVVJMLFxuICBhc3NlcnRQYXJhbUV4aXN0cyxcbiAgc2V0QmVhcmVyQXV0aFRvT2JqZWN0LFxuICBzZXRTZWFyY2hQYXJhbXMsXG4gIHNlcmlhbGl6ZURhdGFJZk5lZWRlZCxcbiAgdG9QYXRoU3RyaW5nLFxuICBjcmVhdGVSZXF1ZXN0RnVuY3Rpb25cbn0gZnJvbSBcIi4uL2NvbW1vblwiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHtcbiAgQkFTRV9QQVRILFxuICBDT0xMRUNUSU9OX0ZPUk1BVFMsXG4gIFJlcXVlc3RBcmdzLFxuICBCYXNlQVBJLFxuICBSZXF1aXJlZEVycm9yXG59IGZyb20gXCIuLi9iYXNlXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBCdXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0IH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgQ3JlYXRlQnVzaW5lc3NUcmFuc2ZlclJlc3BvbnNlIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgQ3JlYXRlVHJhbnNmZXJSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEdldEJ1c2luZXNzVHJhbnNmZXJSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEdldFRyYW5zZmVyUmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBMaXN0QnVzaW5lc3NUcmFuc2ZlcnNSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IExpc3RUcmFuc2ZlcnNSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IE5vdEF1dGhvcml6ZWQgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKFxuICBjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvblxuKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQSB0cmFuc2ZlciBjYW4gYmUgbWFkZSBmcm9tIGFuIGV4aXN0aW5nIGJ1c2luZXNzIGFjY291bnQgdG8gYSBibG9ja2NoYWluIGxvY2F0aW9uLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtCdXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0fSBbYnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlQnVzaW5lc3NUcmFuc2ZlcjogYXN5bmMgKFxuICAgICAgYnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdD86IEJ1c2luZXNzVHJhbnNmZXJDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvYnVzaW5lc3NBY2NvdW50L3RyYW5zZmVyc2A7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlcltcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gc2VyaWFsaXplRGF0YUlmTmVlZGVkKFxuICAgICAgICBidXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZmVyIGNhbiBiZSBtYWRlIGZyb20gYW4gZXhpc3RpbmcgZnVuZGVkIHdhbGxldCB0byBhIGJsb2NrY2hhaW4gYWRkcmVzcyBvciBhbm90aGVyIHdhbGxldC5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7VHJhbnNmZXJDcmVhdGlvblJlcXVlc3R9IFt0cmFuc2ZlckNyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNmZXI6IGFzeW5jIChcbiAgICAgIHRyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0PzogVHJhbnNmZXJDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvdHJhbnNmZXJzYDtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQoXG4gICAgICAgIHRyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRCdXNpbmVzc1RyYW5zZmVyOiBhc3luYyAoXG4gICAgICBpZDogc3RyaW5nLFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBhc3NlcnRQYXJhbUV4aXN0cyhcImdldEJ1c2luZXNzVHJhbnNmZXJcIiwgXCJpZFwiLCBpZCk7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2J1c2luZXNzQWNjb3VudC90cmFuc2ZlcnMve2lkfWAucmVwbGFjZShcbiAgICAgICAgYHske1wiaWRcIn19YCxcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhpZCkpXG4gICAgICApO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybklkZW50aXRpZXNdIFNwZWNpZnkgaWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGlkZW50aXRpZXMgaW4gdGhlIHJlc3BvbnNlLiBSZXN0cmljdHMgbWF4aW11bSByZXR1cm5lZCBpdGVtcyB0byA1LiBCeSBkZWZhdWx0IHJldHVybklkZW50aXRpZXMgaXMgZmFsc2UsIHJlc3VsdGluZyBpbiB0aGUgcmVzcG9uc2Ugbm90IHJldHVybmluZyAmI3g2MDtkYXRhLnNvdXJjZS5pZGVudGl0aWVzJiN4NjA7LlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRUcmFuc2ZlcjogYXN5bmMgKFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIHJldHVybklkZW50aXRpZXM/OiBib29sZWFuLFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdpZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBhc3NlcnRQYXJhbUV4aXN0cyhcImdldFRyYW5zZmVyXCIsIFwiaWRcIiwgaWQpO1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS90cmFuc2ZlcnMve2lkfWAucmVwbGFjZShcbiAgICAgICAgYHske1wiaWRcIn19YCxcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhpZCkpXG4gICAgICApO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAocmV0dXJuSWRlbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJyZXR1cm5JZGVudGl0aWVzXCJdID0gcmV0dXJuSWRlbnRpdGllcztcbiAgICAgIH1cblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHRyYW5zZmVycyBmcm9tIHlvdXIgYnVzaW5lc3MgYWNjb3VudC4gSWYgdGhlIGRhdGUgcGFyYW1ldGVycyBhcmUgb21pdHRlZCwgcmV0dXJucyB0aGUgbW9zdCByZWNlbnQgdHJhbnNmZXJzLiBUaGlzIGVuZHBvaW50IHJldHVybnMgdXAgdG8gNTAgdHJhbnNmZXJzIGluIGRlc2NlbmRpbmcgY2hyb25vbG9naWNhbCBvcmRlciBvciBwYWdlU2l6ZSwgaWYgcHJvdmlkZWQuXG4gICAgICogQHN1bW1hcnkgTGlzdCBhbGwgdHJhbnNmZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQWZ0ZXJdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBiZWdpbiBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYWZ0ZXIgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUJlZm9yZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGxpc3RCdXNpbmVzc1RyYW5zZmVyczogYXN5bmMgKFxuICAgICAgZnJvbT86IHN0cmluZyxcbiAgICAgIHRvPzogc3RyaW5nLFxuICAgICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgICAgb3B0aW9uczogQXhpb3NSZXF1ZXN0Q29uZmlnID0ge31cbiAgICApOiBQcm9taXNlPFJlcXVlc3RBcmdzPiA9PiB7XG4gICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL2J1c2luZXNzQWNjb3VudC90cmFuc2ZlcnNgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAoZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJmcm9tXCJdID1cbiAgICAgICAgICAoZnJvbSBhcyBhbnkpIGluc3RhbmNlb2YgRGF0ZSA/IChmcm9tIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IGZyb207XG4gICAgICB9XG5cbiAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJ0b1wiXSA9XG4gICAgICAgICAgKHRvIGFzIGFueSkgaW5zdGFuY2VvZiBEYXRlID8gKHRvIGFzIGFueSkudG9JU09TdHJpbmcoKSA6IHRvO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZUJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQmVmb3JlXCJdID0gcGFnZUJlZm9yZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VBZnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlQWZ0ZXJcIl0gPSBwYWdlQWZ0ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJwYWdlU2l6ZVwiXSA9IHBhZ2VTaXplO1xuICAgICAgfVxuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBmb3IgdHJhbnNmZXJzIGludm9sdmluZyB0aGUgcHJvdmlkZWQgd2FsbGV0cy4gSWYgbm8gd2FsbGV0IGlkcyBhcmUgcHJvdmlkZWQsIHNlYXJjaGVzIGFsbCB3YWxsZXRzIGFzc29jaWF0ZWQgd2l0aCB5b3VyIENpcmNsZSBBUEkgYWNjb3VudC4gSWYgdGhlIGRhdGUgcGFyYW1ldGVycyBhcmUgb21pdHRlZCwgcmV0dXJucyB0aGUgbW9zdCByZWNlbnQgdHJhbnNmZXJzLiBUaGlzIGVuZHBvaW50IHJldHVybnMgdXAgdG8gNTAgdHJhbnNmZXJzIGluIGRlc2NlbmRpbmcgY2hyb25vbG9naWNhbCBvcmRlciBvciBwYWdlU2l6ZSwgaWYgcHJvdmlkZWQuXG4gICAgICogQHN1bW1hcnkgTGlzdCBhbGwgdHJhbnNmZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt3YWxsZXRJZF0gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzb3VyY2Ugb3IgZGVzdGluYXRpb24gd2FsbGV0IG9mIHRyYW5zZmVycywgaWYgYW55LiBNYXkgbm90IGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBkZXN0aW5hdGlvbldhbGxldElkIG9yIHNvdXJjZVdhbGxldElkLiBVc2VmdWwgZm9yIGZldGNoaW5nIGFsbCB0cmFuc2ZlcnMgcmVsYXRlZCB0byBhIHdhbGxldC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NvdXJjZVdhbGxldElkXSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNvdXJjZSB3YWxsZXQgb2YgdHJhbnNmZXJzLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXN0aW5hdGlvbldhbGxldElkXSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGRlc3RpbmF0aW9uIHdhbGxldCBvZiB0cmFuc2ZlcnMsIGlmIGFueS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXR1cm5JZGVudGl0aWVzXSBTcGVjaWZ5IGlmIHlvdSB3b3VsZCBsaWtlIHRvIHNlZSBpZGVudGl0aWVzIGluIHRoZSByZXNwb25zZS4gUmVzdHJpY3RzIG1heGltdW0gcmV0dXJuZWQgaXRlbXMgdG8gNS4gQnkgZGVmYXVsdCByZXR1cm5JZGVudGl0aWVzIGlzIGZhbHNlLCByZXN1bHRpbmcgaW4gdGhlIHJlc3BvbnNlIG5vdCByZXR1cm5pbmcgJiN4NjA7ZGF0YS5zb3VyY2UuaWRlbnRpdGllcyYjeDYwOy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUJlZm9yZV0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGVuZCBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYmVmb3JlIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VBZnRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgbGlzdFRyYW5zZmVyczogYXN5bmMgKFxuICAgICAgd2FsbGV0SWQ/OiBzdHJpbmcsXG4gICAgICBzb3VyY2VXYWxsZXRJZD86IHN0cmluZyxcbiAgICAgIGRlc3RpbmF0aW9uV2FsbGV0SWQ/OiBzdHJpbmcsXG4gICAgICByZXR1cm5JZGVudGl0aWVzPzogYm9vbGVhbixcbiAgICAgIGZyb20/OiBzdHJpbmcsXG4gICAgICB0bz86IHN0cmluZyxcbiAgICAgIHBhZ2VCZWZvcmU/OiBzdHJpbmcsXG4gICAgICBwYWdlQWZ0ZXI/OiBzdHJpbmcsXG4gICAgICBwYWdlU2l6ZT86IG51bWJlcixcbiAgICAgIG9wdGlvbnM6IEF4aW9zUmVxdWVzdENvbmZpZyA9IHt9XG4gICAgKTogUHJvbWlzZTxSZXF1ZXN0QXJncz4gPT4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS90cmFuc2ZlcnNgO1xuICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBEVU1NWV9CQVNFX1VSTCk7XG4gICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgLi4uYmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9IGFzIGFueTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fSBhcyBhbnk7XG5cbiAgICAgIC8vIGF1dGhlbnRpY2F0aW9uIGJlYXJlckF1dGggcmVxdWlyZWRcbiAgICAgIC8vIGh0dHAgYmVhcmVyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVkXG4gICAgICBhd2FpdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QobG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIGNvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBpZiAod2FsbGV0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wid2FsbGV0SWRcIl0gPSB3YWxsZXRJZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZVdhbGxldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInNvdXJjZVdhbGxldElkXCJdID0gc291cmNlV2FsbGV0SWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbldhbGxldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcImRlc3RpbmF0aW9uV2FsbGV0SWRcIl0gPSBkZXN0aW5hdGlvbldhbGxldElkO1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuSWRlbnRpdGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJyZXR1cm5JZGVudGl0aWVzXCJdID0gcmV0dXJuSWRlbnRpdGllcztcbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wiZnJvbVwiXSA9XG4gICAgICAgICAgKGZyb20gYXMgYW55KSBpbnN0YW5jZW9mIERhdGUgPyAoZnJvbSBhcyBhbnkpLnRvSVNPU3RyaW5nKCkgOiBmcm9tO1xuICAgICAgfVxuXG4gICAgICBpZiAodG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1widG9cIl0gPVxuICAgICAgICAgICh0byBhcyBhbnkpIGluc3RhbmNlb2YgRGF0ZSA/ICh0byBhcyBhbnkpLnRvSVNPU3RyaW5nKCkgOiB0bztcbiAgICAgIH1cblxuICAgICAgaWYgKHBhZ2VCZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wicGFnZUJlZm9yZVwiXSA9IHBhZ2VCZWZvcmU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlQWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wicGFnZUFmdGVyXCJdID0gcGFnZUFmdGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyW1wicGFnZVNpemVcIl0gPSBwYWdlU2l6ZTtcbiAgICAgIH1cblxuICAgICAgc2V0U2VhcmNoUGFyYW1zKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID1cbiAgICAgICAgYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHtcbiAgICAgICAgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsXG4gICAgICAgIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMuaGVhZGVyc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiB0b1BhdGhTdHJpbmcobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYW5zZmVyc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uKSB7XG4gIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPVxuICAgIFRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEEgdHJhbnNmZXIgY2FuIGJlIG1hZGUgZnJvbSBhbiBleGlzdGluZyBidXNpbmVzcyBhY2NvdW50IHRvIGEgYmxvY2tjaGFpbiBsb2NhdGlvbi5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7QnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzVHJhbnNmZXJDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUJ1c2luZXNzVHJhbnNmZXIoXG4gICAgICBidXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxDcmVhdGVCdXNpbmVzc1RyYW5zZmVyUmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9XG4gICAgICAgIGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlQnVzaW5lc3NUcmFuc2ZlcihcbiAgICAgICAgICBidXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQSB0cmFuc2ZlciBjYW4gYmUgbWFkZSBmcm9tIGFuIGV4aXN0aW5nIGZ1bmRlZCB3YWxsZXQgdG8gYSBibG9ja2NoYWluIGFkZHJlc3Mgb3IgYW5vdGhlciB3YWxsZXQuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgdHJhbnNmZXJcbiAgICAgKiBAcGFyYW0ge1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0fSBbdHJhbnNmZXJDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRyYW5zZmVyKFxuICAgICAgdHJhbnNmZXJDcmVhdGlvblJlcXVlc3Q/OiBUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxDcmVhdGVUcmFuc2ZlclJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVRyYW5zZmVyKFxuICAgICAgICB0cmFuc2ZlckNyZWF0aW9uUmVxdWVzdCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgYXN5bmMgZ2V0QnVzaW5lc3NUcmFuc2ZlcihcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8R2V0QnVzaW5lc3NUcmFuc2ZlclJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPVxuICAgICAgICBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEJ1c2luZXNzVHJhbnNmZXIoaWQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybklkZW50aXRpZXNdIFNwZWNpZnkgaWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGlkZW50aXRpZXMgaW4gdGhlIHJlc3BvbnNlLiBSZXN0cmljdHMgbWF4aW11bSByZXR1cm5lZCBpdGVtcyB0byA1LiBCeSBkZWZhdWx0IHJldHVybklkZW50aXRpZXMgaXMgZmFsc2UsIHJlc3VsdGluZyBpbiB0aGUgcmVzcG9uc2Ugbm90IHJldHVybmluZyAmI3g2MDtkYXRhLnNvdXJjZS5pZGVudGl0aWVzJiN4NjA7LlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBnZXRUcmFuc2ZlcihcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICByZXR1cm5JZGVudGl0aWVzPzogYm9vbGVhbixcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxHZXRUcmFuc2ZlclJlc3BvbnNlPlxuICAgID4ge1xuICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFRyYW5zZmVyKFxuICAgICAgICBpZCxcbiAgICAgICAgcmV0dXJuSWRlbnRpdGllcyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHRyYW5zZmVycyBmcm9tIHlvdXIgYnVzaW5lc3MgYWNjb3VudC4gSWYgdGhlIGRhdGUgcGFyYW1ldGVycyBhcmUgb21pdHRlZCwgcmV0dXJucyB0aGUgbW9zdCByZWNlbnQgdHJhbnNmZXJzLiBUaGlzIGVuZHBvaW50IHJldHVybnMgdXAgdG8gNTAgdHJhbnNmZXJzIGluIGRlc2NlbmRpbmcgY2hyb25vbG9naWNhbCBvcmRlciBvciBwYWdlU2l6ZSwgaWYgcHJvdmlkZWQuXG4gICAgICogQHN1bW1hcnkgTGlzdCBhbGwgdHJhbnNmZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQWZ0ZXJdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBiZWdpbiBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYWZ0ZXIgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUJlZm9yZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RCdXNpbmVzc1RyYW5zZmVycyhcbiAgICAgIGZyb20/OiBzdHJpbmcsXG4gICAgICB0bz86IHN0cmluZyxcbiAgICAgIHBhZ2VCZWZvcmU/OiBzdHJpbmcsXG4gICAgICBwYWdlQWZ0ZXI/OiBzdHJpbmcsXG4gICAgICBwYWdlU2l6ZT86IG51bWJlcixcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxMaXN0QnVzaW5lc3NUcmFuc2ZlcnNSZXNwb25zZT5cbiAgICA+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID1cbiAgICAgICAgYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QnVzaW5lc3NUcmFuc2ZlcnMoXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB0byxcbiAgICAgICAgICBwYWdlQmVmb3JlLFxuICAgICAgICAgIHBhZ2VBZnRlcixcbiAgICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciB0cmFuc2ZlcnMgaW52b2x2aW5nIHRoZSBwcm92aWRlZCB3YWxsZXRzLiBJZiBubyB3YWxsZXQgaWRzIGFyZSBwcm92aWRlZCwgc2VhcmNoZXMgYWxsIHdhbGxldHMgYXNzb2NpYXRlZCB3aXRoIHlvdXIgQ2lyY2xlIEFQSSBhY2NvdW50LiBJZiB0aGUgZGF0ZSBwYXJhbWV0ZXJzIGFyZSBvbWl0dGVkLCByZXR1cm5zIHRoZSBtb3N0IHJlY2VudCB0cmFuc2ZlcnMuIFRoaXMgZW5kcG9pbnQgcmV0dXJucyB1cCB0byA1MCB0cmFuc2ZlcnMgaW4gZGVzY2VuZGluZyBjaHJvbm9sb2dpY2FsIG9yZGVyIG9yIHBhZ2VTaXplLCBpZiBwcm92aWRlZC5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGFsbCB0cmFuc2ZlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3dhbGxldElkXSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIHNvdXJjZSBvciBkZXN0aW5hdGlvbiB3YWxsZXQgb2YgdHJhbnNmZXJzLCBpZiBhbnkuIE1heSBub3QgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGRlc3RpbmF0aW9uV2FsbGV0SWQgb3Igc291cmNlV2FsbGV0SWQuIFVzZWZ1bCBmb3IgZmV0Y2hpbmcgYWxsIHRyYW5zZmVycyByZWxhdGVkIHRvIGEgd2FsbGV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlV2FsbGV0SWRdIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc291cmNlIHdhbGxldCBvZiB0cmFuc2ZlcnMsIGlmIGFueS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Rlc3RpbmF0aW9uV2FsbGV0SWRdIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZGVzdGluYXRpb24gd2FsbGV0IG9mIHRyYW5zZmVycywgaWYgYW55LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybklkZW50aXRpZXNdIFNwZWNpZnkgaWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGlkZW50aXRpZXMgaW4gdGhlIHJlc3BvbnNlLiBSZXN0cmljdHMgbWF4aW11bSByZXR1cm5lZCBpdGVtcyB0byA1LiBCeSBkZWZhdWx0IHJldHVybklkZW50aXRpZXMgaXMgZmFsc2UsIHJlc3VsdGluZyBpbiB0aGUgcmVzcG9uc2Ugbm90IHJldHVybmluZyAmI3g2MDtkYXRhLnNvdXJjZS5pZGVudGl0aWVzJiN4NjA7LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VHJhbnNmZXJzKFxuICAgICAgd2FsbGV0SWQ/OiBzdHJpbmcsXG4gICAgICBzb3VyY2VXYWxsZXRJZD86IHN0cmluZyxcbiAgICAgIGRlc3RpbmF0aW9uV2FsbGV0SWQ/OiBzdHJpbmcsXG4gICAgICByZXR1cm5JZGVudGl0aWVzPzogYm9vbGVhbixcbiAgICAgIGZyb20/OiBzdHJpbmcsXG4gICAgICB0bz86IHN0cmluZyxcbiAgICAgIHBhZ2VCZWZvcmU/OiBzdHJpbmcsXG4gICAgICBwYWdlQWZ0ZXI/OiBzdHJpbmcsXG4gICAgICBwYWdlU2l6ZT86IG51bWJlcixcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxMaXN0VHJhbnNmZXJzUmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFRyYW5zZmVycyhcbiAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgIHNvdXJjZVdhbGxldElkLFxuICAgICAgICBkZXN0aW5hdGlvbldhbGxldElkLFxuICAgICAgICByZXR1cm5JZGVudGl0aWVzLFxuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgcGFnZUFmdGVyLFxuICAgICAgICBwYWdlU2l6ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IFRyYW5zZmVyc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uLFxuICBiYXNlUGF0aD86IHN0cmluZyxcbiAgYXhpb3M/OiBBeGlvc0luc3RhbmNlXG4pIHtcbiAgY29uc3QgbG9jYWxWYXJGcCA9IFRyYW5zZmVyc0FwaUZwKGNvbmZpZ3VyYXRpb24pO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEEgdHJhbnNmZXIgY2FuIGJlIG1hZGUgZnJvbSBhbiBleGlzdGluZyBidXNpbmVzcyBhY2NvdW50IHRvIGEgYmxvY2tjaGFpbiBsb2NhdGlvbi5cbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7QnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzVHJhbnNmZXJDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZUJ1c2luZXNzVHJhbnNmZXIoXG4gICAgICBidXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0PzogQnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8Q3JlYXRlQnVzaW5lc3NUcmFuc2ZlclJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuY3JlYXRlQnVzaW5lc3NUcmFuc2ZlcihidXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEEgdHJhbnNmZXIgY2FuIGJlIG1hZGUgZnJvbSBhbiBleGlzdGluZyBmdW5kZWQgd2FsbGV0IHRvIGEgYmxvY2tjaGFpbiBhZGRyZXNzIG9yIGFub3RoZXIgd2FsbGV0LlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdH0gW3RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBjcmVhdGVUcmFuc2ZlcihcbiAgICAgIHRyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0PzogVHJhbnNmZXJDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPENyZWF0ZVRyYW5zZmVyUmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5jcmVhdGVUcmFuc2Zlcih0cmFuc2ZlckNyZWF0aW9uUmVxdWVzdCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRCdXNpbmVzc1RyYW5zZmVyKFxuICAgICAgaWQ6IHN0cmluZyxcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8R2V0QnVzaW5lc3NUcmFuc2ZlclJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuZ2V0QnVzaW5lc3NUcmFuc2ZlcihpZCwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXZlcnNhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEIHY0KSBvZiBhIHJlc291cmNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybklkZW50aXRpZXNdIFNwZWNpZnkgaWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGlkZW50aXRpZXMgaW4gdGhlIHJlc3BvbnNlLiBSZXN0cmljdHMgbWF4aW11bSByZXR1cm5lZCBpdGVtcyB0byA1LiBCeSBkZWZhdWx0IHJldHVybklkZW50aXRpZXMgaXMgZmFsc2UsIHJlc3VsdGluZyBpbiB0aGUgcmVzcG9uc2Ugbm90IHJldHVybmluZyAmI3g2MDtkYXRhLnNvdXJjZS5pZGVudGl0aWVzJiN4NjA7LlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBnZXRUcmFuc2ZlcihcbiAgICAgIGlkOiBzdHJpbmcsXG4gICAgICByZXR1cm5JZGVudGl0aWVzPzogYm9vbGVhbixcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8R2V0VHJhbnNmZXJSZXNwb25zZT4ge1xuICAgICAgcmV0dXJuIGxvY2FsVmFyRnBcbiAgICAgICAgLmdldFRyYW5zZmVyKGlkLCByZXR1cm5JZGVudGl0aWVzLCBvcHRpb25zKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNlYXJjaGVzIGZvciB0cmFuc2ZlcnMgZnJvbSB5b3VyIGJ1c2luZXNzIGFjY291bnQuIElmIHRoZSBkYXRlIHBhcmFtZXRlcnMgYXJlIG9taXR0ZWQsIHJldHVybnMgdGhlIG1vc3QgcmVjZW50IHRyYW5zZmVycy4gVGhpcyBlbmRwb2ludCByZXR1cm5zIHVwIHRvIDUwIHRyYW5zZmVycyBpbiBkZXNjZW5kaW5nIGNocm9ub2xvZ2ljYWwgb3JkZXIgb3IgcGFnZVNpemUsIGlmIHByb3ZpZGVkLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHRyYW5zZmVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdG9dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwYWdlU2l6ZV0gTGltaXRzIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmV0dXJuZWQuICBTb21lIGNvbGxlY3Rpb25zIGhhdmUgYSBzdHJpY3QgdXBwZXIgYm91bmQgdGhhdCB3aWxsIGRpc3JlZ2FyZCB0aGlzIHZhbHVlLiBJbiBjYXNlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgaGlnaGVyIHRoYW4gdGhlIGFsbG93ZWQgbGltaXQsIHRoZSBjb2xsZWN0aW9uIGxpbWl0IHdpbGwgYmUgdXNlZC4gIElmIGF2b2lkZWQsIHRoZSBjb2xsZWN0aW9uIHdpbGwgZGV0ZXJtaW5lIHRoZSBwYWdlIHNpemUgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBsaXN0QnVzaW5lc3NUcmFuc2ZlcnMoXG4gICAgICBmcm9tPzogc3RyaW5nLFxuICAgICAgdG8/OiBzdHJpbmcsXG4gICAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgICAgcGFnZVNpemU/OiBudW1iZXIsXG4gICAgICBvcHRpb25zPzogYW55XG4gICAgKTogQXhpb3NQcm9taXNlPExpc3RCdXNpbmVzc1RyYW5zZmVyc1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAubGlzdEJ1c2luZXNzVHJhbnNmZXJzKFxuICAgICAgICAgIGZyb20sXG4gICAgICAgICAgdG8sXG4gICAgICAgICAgcGFnZUJlZm9yZSxcbiAgICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgICAgcGFnZVNpemUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgZm9yIHRyYW5zZmVycyBpbnZvbHZpbmcgdGhlIHByb3ZpZGVkIHdhbGxldHMuIElmIG5vIHdhbGxldCBpZHMgYXJlIHByb3ZpZGVkLCBzZWFyY2hlcyBhbGwgd2FsbGV0cyBhc3NvY2lhdGVkIHdpdGggeW91ciBDaXJjbGUgQVBJIGFjY291bnQuIElmIHRoZSBkYXRlIHBhcmFtZXRlcnMgYXJlIG9taXR0ZWQsIHJldHVybnMgdGhlIG1vc3QgcmVjZW50IHRyYW5zZmVycy4gVGhpcyBlbmRwb2ludCByZXR1cm5zIHVwIHRvIDUwIHRyYW5zZmVycyBpbiBkZXNjZW5kaW5nIGNocm9ub2xvZ2ljYWwgb3JkZXIgb3IgcGFnZVNpemUsIGlmIHByb3ZpZGVkLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWxsIHRyYW5zZmVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbd2FsbGV0SWRdIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc291cmNlIG9yIGRlc3RpbmF0aW9uIHdhbGxldCBvZiB0cmFuc2ZlcnMsIGlmIGFueS4gTWF5IG5vdCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggZGVzdGluYXRpb25XYWxsZXRJZCBvciBzb3VyY2VXYWxsZXRJZC4gVXNlZnVsIGZvciBmZXRjaGluZyBhbGwgdHJhbnNmZXJzIHJlbGF0ZWQgdG8gYSB3YWxsZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzb3VyY2VXYWxsZXRJZF0gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBzb3VyY2Ugd2FsbGV0IG9mIHRyYW5zZmVycywgaWYgYW55LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZGVzdGluYXRpb25XYWxsZXRJZF0gVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBkZXN0aW5hdGlvbiB3YWxsZXQgb2YgdHJhbnNmZXJzLCBpZiBhbnkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuSWRlbnRpdGllc10gU3BlY2lmeSBpZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgaWRlbnRpdGllcyBpbiB0aGUgcmVzcG9uc2UuIFJlc3RyaWN0cyBtYXhpbXVtIHJldHVybmVkIGl0ZW1zIHRvIDUuIEJ5IGRlZmF1bHQgcmV0dXJuSWRlbnRpdGllcyBpcyBmYWxzZSwgcmVzdWx0aW5nIGluIHRoZSByZXNwb25zZSBub3QgcmV0dXJuaW5nICYjeDYwO2RhdGEuc291cmNlLmlkZW50aXRpZXMmI3g2MDsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcm9tXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgc2luY2UgdGhlIHNwZWNpZmllZCBkYXRlLXRpbWUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQWZ0ZXJdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBiZWdpbiBvZiBhIHBhZ2UuIFdoZW4gcHJvdmlkZWQsIHRoZSBjb2xsZWN0aW9uIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBuZXh0ICYjeDYwO24mI3g2MDsgaXRlbXMgYWZ0ZXIgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUJlZm9yZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGxpc3RUcmFuc2ZlcnMoXG4gICAgICB3YWxsZXRJZD86IHN0cmluZyxcbiAgICAgIHNvdXJjZVdhbGxldElkPzogc3RyaW5nLFxuICAgICAgZGVzdGluYXRpb25XYWxsZXRJZD86IHN0cmluZyxcbiAgICAgIHJldHVybklkZW50aXRpZXM/OiBib29sZWFuLFxuICAgICAgZnJvbT86IHN0cmluZyxcbiAgICAgIHRvPzogc3RyaW5nLFxuICAgICAgcGFnZUJlZm9yZT86IHN0cmluZyxcbiAgICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxMaXN0VHJhbnNmZXJzUmVzcG9uc2U+IHtcbiAgICAgIHJldHVybiBsb2NhbFZhckZwXG4gICAgICAgIC5saXN0VHJhbnNmZXJzKFxuICAgICAgICAgIHdhbGxldElkLFxuICAgICAgICAgIHNvdXJjZVdhbGxldElkLFxuICAgICAgICAgIGRlc3RpbmF0aW9uV2FsbGV0SWQsXG4gICAgICAgICAgcmV0dXJuSWRlbnRpdGllcyxcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRvLFxuICAgICAgICAgIHBhZ2VCZWZvcmUsXG4gICAgICAgICAgcGFnZUFmdGVyLFxuICAgICAgICAgIHBhZ2VTaXplLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFRyYW5zZmVyc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBUcmFuc2ZlcnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5leHBvcnQgY2xhc3MgVHJhbnNmZXJzQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gIC8qKlxuICAgKiBBIHRyYW5zZmVyIGNhbiBiZSBtYWRlIGZyb20gYW4gZXhpc3RpbmcgYnVzaW5lc3MgYWNjb3VudCB0byBhIGJsb2NrY2hhaW4gbG9jYXRpb24uXG4gICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHRyYW5zZmVyXG4gICAqIEBwYXJhbSB7QnVzaW5lc3NUcmFuc2ZlckNyZWF0aW9uUmVxdWVzdH0gW2J1c2luZXNzVHJhbnNmZXJDcmVhdGlvblJlcXVlc3RdXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICovXG4gIHB1YmxpYyBjcmVhdGVCdXNpbmVzc1RyYW5zZmVyKFxuICAgIGJ1c2luZXNzVHJhbnNmZXJDcmVhdGlvblJlcXVlc3Q/OiBCdXNpbmVzc1RyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0LFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIFRyYW5zZmVyc0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5jcmVhdGVCdXNpbmVzc1RyYW5zZmVyKGJ1c2luZXNzVHJhbnNmZXJDcmVhdGlvblJlcXVlc3QsIG9wdGlvbnMpXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICogQSB0cmFuc2ZlciBjYW4gYmUgbWFkZSBmcm9tIGFuIGV4aXN0aW5nIGZ1bmRlZCB3YWxsZXQgdG8gYSBibG9ja2NoYWluIGFkZHJlc3Mgb3IgYW5vdGhlciB3YWxsZXQuXG4gICAqIEBzdW1tYXJ5IENyZWF0ZSBhIHRyYW5zZmVyXG4gICAqIEBwYXJhbSB7VHJhbnNmZXJDcmVhdGlvblJlcXVlc3R9IFt0cmFuc2ZlckNyZWF0aW9uUmVxdWVzdF1cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgKi9cbiAgcHVibGljIGNyZWF0ZVRyYW5zZmVyKFxuICAgIHRyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0PzogVHJhbnNmZXJDcmVhdGlvblJlcXVlc3QsXG4gICAgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZ1xuICApIHtcbiAgICByZXR1cm4gVHJhbnNmZXJzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmNyZWF0ZVRyYW5zZmVyKHRyYW5zZmVyQ3JlYXRpb25SZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzdW1tYXJ5IEdldCBhIHRyYW5zZmVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbml2ZXJzYWxseSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCB2NCkgb2YgYSByZXNvdXJjZS5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgKi9cbiAgcHVibGljIGdldEJ1c2luZXNzVHJhbnNmZXIoaWQ6IHN0cmluZywgb3B0aW9ucz86IEF4aW9zUmVxdWVzdENvbmZpZykge1xuICAgIHJldHVybiBUcmFuc2ZlcnNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuZ2V0QnVzaW5lc3NUcmFuc2ZlcihpZCwgb3B0aW9ucylcbiAgICAgIC50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFuc2ZlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5pdmVyc2FsbHkgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQgdjQpIG9mIGEgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybklkZW50aXRpZXNdIFNwZWNpZnkgaWYgeW91IHdvdWxkIGxpa2UgdG8gc2VlIGlkZW50aXRpZXMgaW4gdGhlIHJlc3BvbnNlLiBSZXN0cmljdHMgbWF4aW11bSByZXR1cm5lZCBpdGVtcyB0byA1LiBCeSBkZWZhdWx0IHJldHVybklkZW50aXRpZXMgaXMgZmFsc2UsIHJlc3VsdGluZyBpbiB0aGUgcmVzcG9uc2Ugbm90IHJldHVybmluZyAmI3g2MDtkYXRhLnNvdXJjZS5pZGVudGl0aWVzJiN4NjA7LlxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgVHJhbnNmZXJzQXBpXG4gICAqL1xuICBwdWJsaWMgZ2V0VHJhbnNmZXIoXG4gICAgaWQ6IHN0cmluZyxcbiAgICByZXR1cm5JZGVudGl0aWVzPzogYm9vbGVhbixcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBUcmFuc2ZlcnNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuZ2V0VHJhbnNmZXIoaWQsIHJldHVybklkZW50aXRpZXMsIG9wdGlvbnMpXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIHRyYW5zZmVycyBmcm9tIHlvdXIgYnVzaW5lc3MgYWNjb3VudC4gSWYgdGhlIGRhdGUgcGFyYW1ldGVycyBhcmUgb21pdHRlZCwgcmV0dXJucyB0aGUgbW9zdCByZWNlbnQgdHJhbnNmZXJzLiBUaGlzIGVuZHBvaW50IHJldHVybnMgdXAgdG8gNTAgdHJhbnNmZXJzIGluIGRlc2NlbmRpbmcgY2hyb25vbG9naWNhbCBvcmRlciBvciBwYWdlU2l6ZSwgaWYgcHJvdmlkZWQuXG4gICAqIEBzdW1tYXJ5IExpc3QgYWxsIHRyYW5zZmVyc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Zyb21dIFF1ZXJpZXMgaXRlbXMgY3JlYXRlZCBzaW5jZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFt0b10gUXVlcmllcyBpdGVtcyBjcmVhdGVkIGJlZm9yZSB0aGUgc3BlY2lmaWVkIGRhdGUtdGltZSAoaW5jbHVzaXZlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlQmVmb3JlXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgZW5kIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBiZWZvcmUgdGhlIGlkLCB3aXRoICYjeDYwO24mI3g2MDsgYmVpbmcgc3BlY2lmaWVkIGJ5ICYjeDYwO3BhZ2VTaXplJiN4NjA7LiAgVGhlIGl0ZW1zIHdpbGwgYmUgcmV0dXJuZWQgaW4gdGhlIG5hdHVyYWwgb3JkZXIgb2YgdGhlIGNvbGxlY3Rpb24uICBUaGUgcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIGZpcnN0IHBhZ2UgaWYgbmVpdGhlciAmI3g2MDtwYWdlQWZ0ZXImI3g2MDsgbm9yICYjeDYwO3BhZ2VCZWZvcmUmI3g2MDsgYXJlIHNwZWNpZmllZC4gIFNIT1VMRCBOT1QgYmUgdXNlZCBpbiBjb25qdWN0aW9uIHdpdGggcGFnZUFmdGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VBZnRlcl0gQSBjb2xsZWN0aW9uIElEIHZhbHVlIHVzZWQgZm9yIHBhZ2luYXRpb24uICBJdCBtYXJrcyB0aGUgZXhjbHVzaXZlIGJlZ2luIG9mIGEgcGFnZS4gV2hlbiBwcm92aWRlZCwgdGhlIGNvbGxlY3Rpb24gcmVzb3VyY2Ugd2lsbCByZXR1cm4gdGhlIG5leHQgJiN4NjA7biYjeDYwOyBpdGVtcyBhZnRlciB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQmVmb3JlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2VTaXplXSBMaW1pdHMgdGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZXR1cm5lZC4gIFNvbWUgY29sbGVjdGlvbnMgaGF2ZSBhIHN0cmljdCB1cHBlciBib3VuZCB0aGF0IHdpbGwgZGlzcmVnYXJkIHRoaXMgdmFsdWUuIEluIGNhc2UgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgYWxsb3dlZCBsaW1pdCwgdGhlIGNvbGxlY3Rpb24gbGltaXQgd2lsbCBiZSB1c2VkLiAgSWYgYXZvaWRlZCwgdGhlIGNvbGxlY3Rpb24gd2lsbCBkZXRlcm1pbmUgdGhlIHBhZ2Ugc2l6ZSBpdHNlbGYuXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICovXG4gIHB1YmxpYyBsaXN0QnVzaW5lc3NUcmFuc2ZlcnMoXG4gICAgZnJvbT86IHN0cmluZyxcbiAgICB0bz86IHN0cmluZyxcbiAgICBwYWdlQmVmb3JlPzogc3RyaW5nLFxuICAgIHBhZ2VBZnRlcj86IHN0cmluZyxcbiAgICBwYWdlU2l6ZT86IG51bWJlcixcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBUcmFuc2ZlcnNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAubGlzdEJ1c2luZXNzVHJhbnNmZXJzKGZyb20sIHRvLCBwYWdlQmVmb3JlLCBwYWdlQWZ0ZXIsIHBhZ2VTaXplLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciB0cmFuc2ZlcnMgaW52b2x2aW5nIHRoZSBwcm92aWRlZCB3YWxsZXRzLiBJZiBubyB3YWxsZXQgaWRzIGFyZSBwcm92aWRlZCwgc2VhcmNoZXMgYWxsIHdhbGxldHMgYXNzb2NpYXRlZCB3aXRoIHlvdXIgQ2lyY2xlIEFQSSBhY2NvdW50LiBJZiB0aGUgZGF0ZSBwYXJhbWV0ZXJzIGFyZSBvbWl0dGVkLCByZXR1cm5zIHRoZSBtb3N0IHJlY2VudCB0cmFuc2ZlcnMuIFRoaXMgZW5kcG9pbnQgcmV0dXJucyB1cCB0byA1MCB0cmFuc2ZlcnMgaW4gZGVzY2VuZGluZyBjaHJvbm9sb2dpY2FsIG9yZGVyIG9yIHBhZ2VTaXplLCBpZiBwcm92aWRlZC5cbiAgICogQHN1bW1hcnkgTGlzdCBhbGwgdHJhbnNmZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbd2FsbGV0SWRdIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc291cmNlIG9yIGRlc3RpbmF0aW9uIHdhbGxldCBvZiB0cmFuc2ZlcnMsIGlmIGFueS4gTWF5IG5vdCBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggZGVzdGluYXRpb25XYWxsZXRJZCBvciBzb3VyY2VXYWxsZXRJZC4gVXNlZnVsIGZvciBmZXRjaGluZyBhbGwgdHJhbnNmZXJzIHJlbGF0ZWQgdG8gYSB3YWxsZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc291cmNlV2FsbGV0SWRdIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc291cmNlIHdhbGxldCBvZiB0cmFuc2ZlcnMsIGlmIGFueS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtkZXN0aW5hdGlvbldhbGxldElkXSBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGRlc3RpbmF0aW9uIHdhbGxldCBvZiB0cmFuc2ZlcnMsIGlmIGFueS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuSWRlbnRpdGllc10gU3BlY2lmeSBpZiB5b3Ugd291bGQgbGlrZSB0byBzZWUgaWRlbnRpdGllcyBpbiB0aGUgcmVzcG9uc2UuIFJlc3RyaWN0cyBtYXhpbXVtIHJldHVybmVkIGl0ZW1zIHRvIDUuIEJ5IGRlZmF1bHQgcmV0dXJuSWRlbnRpdGllcyBpcyBmYWxzZSwgcmVzdWx0aW5nIGluIHRoZSByZXNwb25zZSBub3QgcmV0dXJuaW5nICYjeDYwO2RhdGEuc291cmNlLmlkZW50aXRpZXMmI3g2MDsuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJvbV0gUXVlcmllcyBpdGVtcyBjcmVhdGVkIHNpbmNlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3RvXSBRdWVyaWVzIGl0ZW1zIGNyZWF0ZWQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZGF0ZS10aW1lIChpbmNsdXNpdmUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VCZWZvcmVdIEEgY29sbGVjdGlvbiBJRCB2YWx1ZSB1c2VkIGZvciBwYWdpbmF0aW9uLiAgSXQgbWFya3MgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGJlZm9yZSB0aGUgaWQsIHdpdGggJiN4NjA7biYjeDYwOyBiZWluZyBzcGVjaWZpZWQgYnkgJiN4NjA7cGFnZVNpemUmI3g2MDsuICBUaGUgaXRlbXMgd2lsbCBiZSByZXR1cm5lZCBpbiB0aGUgbmF0dXJhbCBvcmRlciBvZiB0aGUgY29sbGVjdGlvbi4gIFRoZSByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgZmlyc3QgcGFnZSBpZiBuZWl0aGVyICYjeDYwO3BhZ2VBZnRlciYjeDYwOyBub3IgJiN4NjA7cGFnZUJlZm9yZSYjeDYwOyBhcmUgc3BlY2lmaWVkLiAgU0hPVUxEIE5PVCBiZSB1c2VkIGluIGNvbmp1Y3Rpb24gd2l0aCBwYWdlQWZ0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZUFmdGVyXSBBIGNvbGxlY3Rpb24gSUQgdmFsdWUgdXNlZCBmb3IgcGFnaW5hdGlvbi4gIEl0IG1hcmtzIHRoZSBleGNsdXNpdmUgYmVnaW4gb2YgYSBwYWdlLiBXaGVuIHByb3ZpZGVkLCB0aGUgY29sbGVjdGlvbiByZXNvdXJjZSB3aWxsIHJldHVybiB0aGUgbmV4dCAmI3g2MDtuJiN4NjA7IGl0ZW1zIGFmdGVyIHRoZSBpZCwgd2l0aCAmI3g2MDtuJiN4NjA7IGJlaW5nIHNwZWNpZmllZCBieSAmI3g2MDtwYWdlU2l6ZSYjeDYwOy4gIFRoZSBpdGVtcyB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBuYXR1cmFsIG9yZGVyIG9mIHRoZSBjb2xsZWN0aW9uLiAgVGhlIHJlc291cmNlIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBwYWdlIGlmIG5laXRoZXIgJiN4NjA7cGFnZUFmdGVyJiN4NjA7IG5vciAmI3g2MDtwYWdlQmVmb3JlJiN4NjA7IGFyZSBzcGVjaWZpZWQuICBTSE9VTEQgTk9UIGJlIHVzZWQgaW4gY29uanVjdGlvbiB3aXRoIHBhZ2VCZWZvcmUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZVNpemVdIExpbWl0cyB0aGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJldHVybmVkLiAgU29tZSBjb2xsZWN0aW9ucyBoYXZlIGEgc3RyaWN0IHVwcGVyIGJvdW5kIHRoYXQgd2lsbCBkaXNyZWdhcmQgdGhpcyB2YWx1ZS4gSW4gY2FzZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGhpZ2hlciB0aGFuIHRoZSBhbGxvd2VkIGxpbWl0LCB0aGUgY29sbGVjdGlvbiBsaW1pdCB3aWxsIGJlIHVzZWQuICBJZiBhdm9pZGVkLCB0aGUgY29sbGVjdGlvbiB3aWxsIGRldGVybWluZSB0aGUgcGFnZSBzaXplIGl0c2VsZi5cbiAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgKi9cbiAgcHVibGljIGxpc3RUcmFuc2ZlcnMoXG4gICAgd2FsbGV0SWQ/OiBzdHJpbmcsXG4gICAgc291cmNlV2FsbGV0SWQ/OiBzdHJpbmcsXG4gICAgZGVzdGluYXRpb25XYWxsZXRJZD86IHN0cmluZyxcbiAgICByZXR1cm5JZGVudGl0aWVzPzogYm9vbGVhbixcbiAgICBmcm9tPzogc3RyaW5nLFxuICAgIHRvPzogc3RyaW5nLFxuICAgIHBhZ2VCZWZvcmU/OiBzdHJpbmcsXG4gICAgcGFnZUFmdGVyPzogc3RyaW5nLFxuICAgIHBhZ2VTaXplPzogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgKSB7XG4gICAgcmV0dXJuIFRyYW5zZmVyc0FwaUZwKHRoaXMuY29uZmlndXJhdGlvbilcbiAgICAgIC5saXN0VHJhbnNmZXJzKFxuICAgICAgICB3YWxsZXRJZCxcbiAgICAgICAgc291cmNlV2FsbGV0SWQsXG4gICAgICAgIGRlc3RpbmF0aW9uV2FsbGV0SWQsXG4gICAgICAgIHJldHVybklkZW50aXRpZXMsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgICAgICBwYWdlQmVmb3JlLFxuICAgICAgICBwYWdlQWZ0ZXIsXG4gICAgICAgIHBhZ2VTaXplLFxuICAgICAgICBvcHRpb25zXG4gICAgICApXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cbn1cbiJdfQ==