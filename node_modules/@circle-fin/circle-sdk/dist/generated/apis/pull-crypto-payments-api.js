"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PullCryptoPaymentsApi = exports.PullCryptoPaymentsApiFactory = exports.PullCryptoPaymentsApiFp = exports.PullCryptoPaymentsApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * PullCryptoPaymentsApi - axios parameter creator
 * @export
 */
const PullCryptoPaymentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a crypto payment
         * @param {CryptoPaymentCreationRequest} [cryptoPaymentCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCryptoPayment: (cryptoPaymentCreationRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/v1/payments/crypto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(cryptoPaymentCreationRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        }),
        /**
         *
         * @summary Get a typed message for signing
         * @param {string} endUserAddress User wallet address
         * @param {string} paymentIntentId Payment intent id which is from the create payment intent endpoint response
         * @param {string} [amount]
         * @param {'USD'} [currency] Only support USD at the moment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        presign: (endUserAddress, paymentIntentId, amount, currency, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'endUserAddress' is not null or undefined
            (0, common_1.assertParamExists)("presign", "endUserAddress", endUserAddress);
            // verify required parameter 'paymentIntentId' is not null or undefined
            (0, common_1.assertParamExists)("presign", "paymentIntentId", paymentIntentId);
            const localVarPath = `/v1/payments/presign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (endUserAddress !== undefined) {
                localVarQueryParameter["endUserAddress"] = endUserAddress;
            }
            if (paymentIntentId !== undefined) {
                localVarQueryParameter["paymentIntentId"] = paymentIntentId;
            }
            if (amount !== undefined) {
                localVarQueryParameter["amount"] = amount;
            }
            if (currency !== undefined) {
                localVarQueryParameter["currency"] = currency;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.PullCryptoPaymentsApiAxiosParamCreator = PullCryptoPaymentsApiAxiosParamCreator;
/**
 * PullCryptoPaymentsApi - functional programming interface
 * @export
 */
const PullCryptoPaymentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PullCryptoPaymentsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a crypto payment
         * @param {CryptoPaymentCreationRequest} [cryptoPaymentCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCryptoPayment(cryptoPaymentCreationRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCryptoPayment(cryptoPaymentCreationRequest, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a typed message for signing
         * @param {string} endUserAddress User wallet address
         * @param {string} paymentIntentId Payment intent id which is from the create payment intent endpoint response
         * @param {string} [amount]
         * @param {'USD'} [currency] Only support USD at the moment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        presign(endUserAddress, paymentIntentId, amount, currency, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.presign(endUserAddress, paymentIntentId, amount, currency, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.PullCryptoPaymentsApiFp = PullCryptoPaymentsApiFp;
/**
 * PullCryptoPaymentsApi - factory interface
 * @export
 */
const PullCryptoPaymentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PullCryptoPaymentsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a crypto payment
         * @param {CryptoPaymentCreationRequest} [cryptoPaymentCreationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCryptoPayment(cryptoPaymentCreationRequest, options) {
            return localVarFp
                .createCryptoPayment(cryptoPaymentCreationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a typed message for signing
         * @param {string} endUserAddress User wallet address
         * @param {string} paymentIntentId Payment intent id which is from the create payment intent endpoint response
         * @param {string} [amount]
         * @param {'USD'} [currency] Only support USD at the moment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        presign(endUserAddress, paymentIntentId, amount, currency, options) {
            return localVarFp
                .presign(endUserAddress, paymentIntentId, amount, currency, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.PullCryptoPaymentsApiFactory = PullCryptoPaymentsApiFactory;
/**
 * PullCryptoPaymentsApi - object-oriented interface
 * @export
 * @class PullCryptoPaymentsApi
 * @extends {BaseAPI}
 */
class PullCryptoPaymentsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a crypto payment
     * @param {CryptoPaymentCreationRequest} [cryptoPaymentCreationRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullCryptoPaymentsApi
     */
    createCryptoPayment(cryptoPaymentCreationRequest, options) {
        return (0, exports.PullCryptoPaymentsApiFp)(this.configuration)
            .createCryptoPayment(cryptoPaymentCreationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a typed message for signing
     * @param {string} endUserAddress User wallet address
     * @param {string} paymentIntentId Payment intent id which is from the create payment intent endpoint response
     * @param {string} [amount]
     * @param {'USD'} [currency] Only support USD at the moment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PullCryptoPaymentsApi
     */
    presign(endUserAddress, paymentIntentId, amount, currency, options) {
        return (0, exports.PullCryptoPaymentsApiFp)(this.configuration)
            .presign(endUserAddress, paymentIntentId, amount, currency, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PullCryptoPaymentsApi = PullCryptoPaymentsApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVsbC1jcnlwdG8tcGF5bWVudHMtYXBpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2dlbmVyYXRlZC9hcGlzL3B1bGwtY3J5cHRvLXBheW1lbnRzLWFwaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjs7OztHQUlHOzs7Ozs7Ozs7Ozs7Ozs7QUFFSCxrREFJZTtBQUVmLHlEQUF5RDtBQUN6RCxhQUFhO0FBQ2Isc0NBUW1CO0FBQ25CLGFBQWE7QUFDYixrQ0FNaUI7QUFhakI7OztHQUdHO0FBQ0ksTUFBTSxzQ0FBc0MsR0FBRyxVQUNwRCxhQUE2QjtJQUU3QixPQUFPO1FBQ0w7Ozs7OztXQU1HO1FBQ0gsbUJBQW1CLEVBQUUsQ0FDbkIsNEJBQTJELEVBQzNELFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUFHLHFCQUFxQixDQUFDO1lBQzNDLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsTUFBTSxJQUNYLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLHVCQUF1QixDQUFDLGNBQWMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDO1lBRTdELElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJQUFJLHNCQUFzQixHQUN4QixXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLHNCQUFzQixDQUFDLE9BQU8saURBQ3pCLHVCQUF1QixHQUN2QixzQkFBc0IsR0FDdEIsT0FBTyxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztZQUNGLHNCQUFzQixDQUFDLElBQUksR0FBRyxJQUFBLDhCQUFxQixFQUNqRCw0QkFBNEIsRUFDNUIsc0JBQXNCLEVBQ3RCLGFBQWEsQ0FDZCxDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO1FBQ0Q7Ozs7Ozs7OztXQVNHO1FBQ0gsT0FBTyxFQUFFLENBQ1AsY0FBc0IsRUFDdEIsZUFBdUIsRUFDdkIsTUFBZSxFQUNmLFFBQWdCLEVBQ2hCLFVBQThCLEVBQUUsRUFDVixFQUFFO1lBQ3hCLHNFQUFzRTtZQUN0RSxJQUFBLDBCQUFpQixFQUFDLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUMvRCx1RUFBdUU7WUFDdkUsSUFBQSwwQkFBaUIsRUFBQyxTQUFTLEVBQUUsaUJBQWlCLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDakUsTUFBTSxZQUFZLEdBQUcsc0JBQXNCLENBQUM7WUFDNUMsb0ZBQW9GO1lBQ3BGLE1BQU0sY0FBYyxHQUFHLElBQUksR0FBRyxDQUFDLFlBQVksRUFBRSx1QkFBYyxDQUFDLENBQUM7WUFDN0QsSUFBSSxXQUFXLENBQUM7WUFDaEIsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLFdBQVcsR0FBRyxhQUFhLENBQUMsV0FBVyxDQUFDO2FBQ3pDO1lBRUQsTUFBTSxzQkFBc0IsaUNBQzFCLE1BQU0sRUFBRSxLQUFLLElBQ1YsV0FBVyxHQUNYLE9BQU8sQ0FDWCxDQUFDO1lBQ0YsTUFBTSx1QkFBdUIsR0FBRyxFQUFTLENBQUM7WUFDMUMsTUFBTSxzQkFBc0IsR0FBRyxFQUFTLENBQUM7WUFFekMscUNBQXFDO1lBQ3JDLHNDQUFzQztZQUN0QyxNQUFNLElBQUEsOEJBQXFCLEVBQUMsdUJBQXVCLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFFcEUsSUFBSSxjQUFjLEtBQUssU0FBUyxFQUFFO2dCQUNoQyxzQkFBc0IsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLGNBQWMsQ0FBQzthQUMzRDtZQUVELElBQUksZUFBZSxLQUFLLFNBQVMsRUFBRTtnQkFDakMsc0JBQXNCLENBQUMsaUJBQWlCLENBQUMsR0FBRyxlQUFlLENBQUM7YUFDN0Q7WUFFRCxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUU7Z0JBQ3hCLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxHQUFHLE1BQU0sQ0FBQzthQUMzQztZQUVELElBQUksUUFBUSxLQUFLLFNBQVMsRUFBRTtnQkFDMUIsc0JBQXNCLENBQUMsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDO2FBQy9DO1lBRUQsSUFBQSx3QkFBZSxFQUFDLGNBQWMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hELElBQUksc0JBQXNCLEdBQ3hCLFdBQVcsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDaEUsc0JBQXNCLENBQUMsT0FBTyxpREFDekIsdUJBQXVCLEdBQ3ZCLHNCQUFzQixHQUN0QixPQUFPLENBQUMsT0FBTyxDQUNuQixDQUFDO1lBRUYsT0FBTztnQkFDTCxHQUFHLEVBQUUsSUFBQSxxQkFBWSxFQUFDLGNBQWMsQ0FBQztnQkFDakMsT0FBTyxFQUFFLHNCQUFzQjthQUNoQyxDQUFDO1FBQ0osQ0FBQyxDQUFBO0tBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQztBQWhJVyxRQUFBLHNDQUFzQywwQ0FnSWpEO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSx1QkFBdUIsR0FBRyxVQUNyQyxhQUE2QjtJQUU3QixNQUFNLHlCQUF5QixHQUM3QixJQUFBLDhDQUFzQyxFQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3hELE9BQU87UUFDTDs7Ozs7O1dBTUc7UUFDRyxtQkFBbUIsQ0FDdkIsNEJBQTJELEVBQzNELE9BQTRCOztnQkFPNUIsTUFBTSxpQkFBaUIsR0FDckIsTUFBTSx5QkFBeUIsQ0FBQyxtQkFBbUIsQ0FDakQsNEJBQTRCLEVBQzVCLE9BQU8sQ0FDUixDQUFDO2dCQUNKLE9BQU8sSUFBQSw4QkFBcUIsRUFDMUIsaUJBQWlCLEVBQ2pCLGVBQVcsRUFDWCxnQkFBUyxFQUNULGFBQWEsQ0FDZCxDQUFDO1lBQ0osQ0FBQztTQUFBO1FBQ0Q7Ozs7Ozs7OztXQVNHO1FBQ0csT0FBTyxDQUNYLGNBQXNCLEVBQ3RCLGVBQXVCLEVBQ3ZCLE1BQWUsRUFDZixRQUFnQixFQUNoQixPQUE0Qjs7Z0JBTzVCLE1BQU0saUJBQWlCLEdBQUcsTUFBTSx5QkFBeUIsQ0FBQyxPQUFPLENBQy9ELGNBQWMsRUFDZCxlQUFlLEVBQ2YsTUFBTSxFQUNOLFFBQVEsRUFDUixPQUFPLENBQ1IsQ0FBQztnQkFDRixPQUFPLElBQUEsOEJBQXFCLEVBQzFCLGlCQUFpQixFQUNqQixlQUFXLEVBQ1gsZ0JBQVMsRUFDVCxhQUFhLENBQ2QsQ0FBQztZQUNKLENBQUM7U0FBQTtLQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUF2RVcsUUFBQSx1QkFBdUIsMkJBdUVsQztBQUVGOzs7R0FHRztBQUNJLE1BQU0sNEJBQTRCLEdBQUcsVUFDMUMsYUFBNkIsRUFDN0IsUUFBaUIsRUFDakIsS0FBcUI7SUFFckIsTUFBTSxVQUFVLEdBQUcsSUFBQSwrQkFBdUIsRUFBQyxhQUFhLENBQUMsQ0FBQztJQUMxRCxPQUFPO1FBQ0w7Ozs7OztXQU1HO1FBQ0gsbUJBQW1CLENBQ2pCLDRCQUEyRCxFQUMzRCxPQUFhO1lBRWIsT0FBTyxVQUFVO2lCQUNkLG1CQUFtQixDQUFDLDRCQUE0QixFQUFFLE9BQU8sQ0FBQztpQkFDMUQsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakQsQ0FBQztRQUNEOzs7Ozs7Ozs7V0FTRztRQUNILE9BQU8sQ0FDTCxjQUFzQixFQUN0QixlQUF1QixFQUN2QixNQUFlLEVBQ2YsUUFBZ0IsRUFDaEIsT0FBYTtZQUViLE9BQU8sVUFBVTtpQkFDZCxPQUFPLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQztpQkFDbkUsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDakQsQ0FBQztLQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUE1Q1csUUFBQSw0QkFBNEIsZ0NBNEN2QztBQUVGOzs7OztHQUtHO0FBQ0gsTUFBYSxxQkFBc0IsU0FBUSxjQUFPO0lBQ2hEOzs7Ozs7O09BT0c7SUFDSSxtQkFBbUIsQ0FDeEIsNEJBQTJELEVBQzNELE9BQTRCO1FBRTVCLE9BQU8sSUFBQSwrQkFBdUIsRUFBQyxJQUFJLENBQUMsYUFBYSxDQUFDO2FBQy9DLG1CQUFtQixDQUFDLDRCQUE0QixFQUFFLE9BQU8sQ0FBQzthQUMxRCxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRDs7Ozs7Ozs7OztPQVVHO0lBQ0ksT0FBTyxDQUNaLGNBQXNCLEVBQ3RCLGVBQXVCLEVBQ3ZCLE1BQWUsRUFDZixRQUFnQixFQUNoQixPQUE0QjtRQUU1QixPQUFPLElBQUEsK0JBQXVCLEVBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUMvQyxPQUFPLENBQUMsY0FBYyxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLE9BQU8sQ0FBQzthQUNuRSxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0lBQzNELENBQUM7Q0FDRjtBQXhDRCxzREF3Q0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG5cbmltcG9ydCBnbG9iYWxBeGlvcywge1xuICBBeGlvc1Byb21pc2UsXG4gIEF4aW9zSW5zdGFuY2UsXG4gIEF4aW9zUmVxdWVzdENvbmZpZ1xufSBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tIFwiLi4vY29uZmlndXJhdGlvblwiO1xuLy8gU29tZSBpbXBvcnRzIG5vdCB1c2VkIGRlcGVuZGluZyBvbiB0ZW1wbGF0ZSBjb25kaXRpb25zXG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBEVU1NWV9CQVNFX1VSTCxcbiAgYXNzZXJ0UGFyYW1FeGlzdHMsXG4gIHNldEJlYXJlckF1dGhUb09iamVjdCxcbiAgc2V0U2VhcmNoUGFyYW1zLFxuICBzZXJpYWxpemVEYXRhSWZOZWVkZWQsXG4gIHRvUGF0aFN0cmluZyxcbiAgY3JlYXRlUmVxdWVzdEZ1bmN0aW9uXG59IGZyb20gXCIuLi9jb21tb25cIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7XG4gIEJBU0VfUEFUSCxcbiAgQ09MTEVDVElPTl9GT1JNQVRTLFxuICBSZXF1ZXN0QXJncyxcbiAgQmFzZUFQSSxcbiAgUmVxdWlyZWRFcnJvclxufSBmcm9tIFwiLi4vYmFzZVwiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgQmFkUmVxdWVzdCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENyZWF0ZUNyeXB0b1BheW1lbnRSZXNwb25zZSB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IENyZWF0ZUNyeXB0b1BheW1lbnRSZXNwb25zZTEgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBDcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0IH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHsgTm90QXV0aG9yaXplZCB9IGZyb20gXCIuLi9tb2RlbHNcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IE5vdEZvdW5kIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLyoqXG4gKiBQdWxsQ3J5cHRvUGF5bWVudHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgUHVsbENyeXB0b1BheW1lbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uXG4pIHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIGNyeXB0byBwYXltZW50XG4gICAgICogQHBhcmFtIHtDcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0fSBbY3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgY3JlYXRlQ3J5cHRvUGF5bWVudDogYXN5bmMgKFxuICAgICAgY3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdD86IENyeXB0b1BheW1lbnRDcmVhdGlvblJlcXVlc3QsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvcGF5bWVudHMvY3J5cHRvYDtcbiAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSBzZXJpYWxpemVEYXRhSWZOZWVkZWQoXG4gICAgICAgIGNyeXB0b1BheW1lbnRDcmVhdGlvblJlcXVlc3QsXG4gICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgdHlwZWQgbWVzc2FnZSBmb3Igc2lnbmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRVc2VyQWRkcmVzcyBVc2VyIHdhbGxldCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBheW1lbnRJbnRlbnRJZCBQYXltZW50IGludGVudCBpZCB3aGljaCBpcyBmcm9tIHRoZSBjcmVhdGUgcGF5bWVudCBpbnRlbnQgZW5kcG9pbnQgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Ftb3VudF1cbiAgICAgKiBAcGFyYW0geydVU0QnfSBbY3VycmVuY3ldIE9ubHkgc3VwcG9ydCBVU0QgYXQgdGhlIG1vbWVudFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBwcmVzaWduOiBhc3luYyAoXG4gICAgICBlbmRVc2VyQWRkcmVzczogc3RyaW5nLFxuICAgICAgcGF5bWVudEludGVudElkOiBzdHJpbmcsXG4gICAgICBhbW91bnQ/OiBzdHJpbmcsXG4gICAgICBjdXJyZW5jeT86IFwiVVNEXCIsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2VuZFVzZXJBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgIGFzc2VydFBhcmFtRXhpc3RzKFwicHJlc2lnblwiLCBcImVuZFVzZXJBZGRyZXNzXCIsIGVuZFVzZXJBZGRyZXNzKTtcbiAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3BheW1lbnRJbnRlbnRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBhc3NlcnRQYXJhbUV4aXN0cyhcInByZXNpZ25cIiwgXCJwYXltZW50SW50ZW50SWRcIiwgcGF5bWVudEludGVudElkKTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvcGF5bWVudHMvcHJlc2lnbmA7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIGlmIChlbmRVc2VyQWRkcmVzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJlbmRVc2VyQWRkcmVzc1wiXSA9IGVuZFVzZXJBZGRyZXNzO1xuICAgICAgfVxuXG4gICAgICBpZiAocGF5bWVudEludGVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcltcInBheW1lbnRJbnRlbnRJZFwiXSA9IHBheW1lbnRJbnRlbnRJZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFtb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJhbW91bnRcIl0gPSBhbW91bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW5jeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbXCJjdXJyZW5jeVwiXSA9IGN1cnJlbmN5O1xuICAgICAgfVxuXG4gICAgICBzZXRTZWFyY2hQYXJhbXMobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPVxuICAgICAgICBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlcixcbiAgICAgICAgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHRvUGF0aFN0cmluZyhsb2NhbFZhclVybE9iaiksXG4gICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQdWxsQ3J5cHRvUGF5bWVudHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgUHVsbENyeXB0b1BheW1lbnRzQXBpRnAgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uXG4pIHtcbiAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9XG4gICAgUHVsbENyeXB0b1BheW1lbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBjcnlwdG8gcGF5bWVudFxuICAgICAqIEBwYXJhbSB7Q3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdH0gW2NyeXB0b1BheW1lbnRDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNyeXB0b1BheW1lbnQoXG4gICAgICBjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0PzogQ3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxDcmVhdGVDcnlwdG9QYXltZW50UmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9XG4gICAgICAgIGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlQ3J5cHRvUGF5bWVudChcbiAgICAgICAgICBjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0RnVuY3Rpb24oXG4gICAgICAgIGxvY2FsVmFyQXhpb3NBcmdzLFxuICAgICAgICBnbG9iYWxBeGlvcyxcbiAgICAgICAgQkFTRV9QQVRILFxuICAgICAgICBjb25maWd1cmF0aW9uXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB0eXBlZCBtZXNzYWdlIGZvciBzaWduaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFVzZXJBZGRyZXNzIFVzZXIgd2FsbGV0IGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bWVudEludGVudElkIFBheW1lbnQgaW50ZW50IGlkIHdoaWNoIGlzIGZyb20gdGhlIGNyZWF0ZSBwYXltZW50IGludGVudCBlbmRwb2ludCByZXNwb25zZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYW1vdW50XVxuICAgICAqIEBwYXJhbSB7J1VTRCd9IFtjdXJyZW5jeV0gT25seSBzdXBwb3J0IFVTRCBhdCB0aGUgbW9tZW50XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIHByZXNpZ24oXG4gICAgICBlbmRVc2VyQWRkcmVzczogc3RyaW5nLFxuICAgICAgcGF5bWVudEludGVudElkOiBzdHJpbmcsXG4gICAgICBhbW91bnQ/OiBzdHJpbmcsXG4gICAgICBjdXJyZW5jeT86IFwiVVNEXCIsXG4gICAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICAgKTogUHJvbWlzZTxcbiAgICAgIChcbiAgICAgICAgYXhpb3M/OiBBeGlvc0luc3RhbmNlLFxuICAgICAgICBiYXNlUGF0aD86IHN0cmluZ1xuICAgICAgKSA9PiBBeGlvc1Byb21pc2U8Q3JlYXRlQ3J5cHRvUGF5bWVudFJlc3BvbnNlMT5cbiAgICA+IHtcbiAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5wcmVzaWduKFxuICAgICAgICBlbmRVc2VyQWRkcmVzcyxcbiAgICAgICAgcGF5bWVudEludGVudElkLFxuICAgICAgICBhbW91bnQsXG4gICAgICAgIGN1cnJlbmN5LFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlcXVlc3RGdW5jdGlvbihcbiAgICAgICAgbG9jYWxWYXJBeGlvc0FyZ3MsXG4gICAgICAgIGdsb2JhbEF4aW9zLFxuICAgICAgICBCQVNFX1BBVEgsXG4gICAgICAgIGNvbmZpZ3VyYXRpb25cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQdWxsQ3J5cHRvUGF5bWVudHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgUHVsbENyeXB0b1BheW1lbnRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb24sXG4gIGJhc2VQYXRoPzogc3RyaW5nLFxuICBheGlvcz86IEF4aW9zSW5zdGFuY2Vcbikge1xuICBjb25zdCBsb2NhbFZhckZwID0gUHVsbENyeXB0b1BheW1lbnRzQXBpRnAoY29uZmlndXJhdGlvbik7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBjcnlwdG8gcGF5bWVudFxuICAgICAqIEBwYXJhbSB7Q3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdH0gW2NyeXB0b1BheW1lbnRDcmVhdGlvblJlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZUNyeXB0b1BheW1lbnQoXG4gICAgICBjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0PzogQ3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdCxcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8Q3JlYXRlQ3J5cHRvUGF5bWVudFJlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuY3JlYXRlQ3J5cHRvUGF5bWVudChjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgdHlwZWQgbWVzc2FnZSBmb3Igc2lnbmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRVc2VyQWRkcmVzcyBVc2VyIHdhbGxldCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBheW1lbnRJbnRlbnRJZCBQYXltZW50IGludGVudCBpZCB3aGljaCBpcyBmcm9tIHRoZSBjcmVhdGUgcGF5bWVudCBpbnRlbnQgZW5kcG9pbnQgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Ftb3VudF1cbiAgICAgKiBAcGFyYW0geydVU0QnfSBbY3VycmVuY3ldIE9ubHkgc3VwcG9ydCBVU0QgYXQgdGhlIG1vbWVudFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKi9cbiAgICBwcmVzaWduKFxuICAgICAgZW5kVXNlckFkZHJlc3M6IHN0cmluZyxcbiAgICAgIHBheW1lbnRJbnRlbnRJZDogc3RyaW5nLFxuICAgICAgYW1vdW50Pzogc3RyaW5nLFxuICAgICAgY3VycmVuY3k/OiBcIlVTRFwiLFxuICAgICAgb3B0aW9ucz86IGFueVxuICAgICk6IEF4aW9zUHJvbWlzZTxDcmVhdGVDcnlwdG9QYXltZW50UmVzcG9uc2UxPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAucHJlc2lnbihlbmRVc2VyQWRkcmVzcywgcGF5bWVudEludGVudElkLCBhbW91bnQsIGN1cnJlbmN5LCBvcHRpb25zKVxuICAgICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIFB1bGxDcnlwdG9QYXltZW50c0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBQdWxsQ3J5cHRvUGF5bWVudHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5leHBvcnQgY2xhc3MgUHVsbENyeXB0b1BheW1lbnRzQXBpIGV4dGVuZHMgQmFzZUFQSSB7XG4gIC8qKlxuICAgKlxuICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBjcnlwdG8gcGF5bWVudFxuICAgKiBAcGFyYW0ge0NyeXB0b1BheW1lbnRDcmVhdGlvblJlcXVlc3R9IFtjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0XVxuICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgKiBAbWVtYmVyb2YgUHVsbENyeXB0b1BheW1lbnRzQXBpXG4gICAqL1xuICBwdWJsaWMgY3JlYXRlQ3J5cHRvUGF5bWVudChcbiAgICBjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0PzogQ3J5cHRvUGF5bWVudENyZWF0aW9uUmVxdWVzdCxcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBQdWxsQ3J5cHRvUGF5bWVudHNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAuY3JlYXRlQ3J5cHRvUGF5bWVudChjcnlwdG9QYXltZW50Q3JlYXRpb25SZXF1ZXN0LCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzdW1tYXJ5IEdldCBhIHR5cGVkIG1lc3NhZ2UgZm9yIHNpZ25pbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFVzZXJBZGRyZXNzIFVzZXIgd2FsbGV0IGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBheW1lbnRJbnRlbnRJZCBQYXltZW50IGludGVudCBpZCB3aGljaCBpcyBmcm9tIHRoZSBjcmVhdGUgcGF5bWVudCBpbnRlbnQgZW5kcG9pbnQgcmVzcG9uc2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFthbW91bnRdXG4gICAqIEBwYXJhbSB7J1VTRCd9IFtjdXJyZW5jeV0gT25seSBzdXBwb3J0IFVTRCBhdCB0aGUgbW9tZW50XG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBQdWxsQ3J5cHRvUGF5bWVudHNBcGlcbiAgICovXG4gIHB1YmxpYyBwcmVzaWduKFxuICAgIGVuZFVzZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgcGF5bWVudEludGVudElkOiBzdHJpbmcsXG4gICAgYW1vdW50Pzogc3RyaW5nLFxuICAgIGN1cnJlbmN5PzogXCJVU0RcIixcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBQdWxsQ3J5cHRvUGF5bWVudHNBcGlGcCh0aGlzLmNvbmZpZ3VyYXRpb24pXG4gICAgICAucHJlc2lnbihlbmRVc2VyQWRkcmVzcywgcGF5bWVudEludGVudElkLCBhbW91bnQsIGN1cnJlbmN5LCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICB9XG59XG4iXX0=