"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoExchangeRatesApi = exports.CryptoExchangeRatesApiFactory = exports.CryptoExchangeRatesApiFp = exports.CryptoExchangeRatesApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * CryptoExchangeRatesApi - axios parameter creator
 * @export
 */
const CryptoExchangeRatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch the current rates for the specified trading pair. The trading pair is defined by a base currency followed by a quote currency. The response contains buy and sell rates denominated in the quote currency. **Exchange rate is an estimate only and is subject to change by the time you submit the actual request.**
         * @summary Get a exchange rate
         * @param {'BTC-USD' | 'ETH-USD' | 'FLOW-USD'} tradingPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRates: (tradingPair, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tradingPair' is not null or undefined
            (0, common_1.assertParamExists)("getExchangeRates", "tradingPair", tradingPair);
            const localVarPath = `/v1/exchange/rates/{trading-pair}`.replace(`{${"trading-pair"}}`, encodeURIComponent(String(tradingPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions
            };
        })
    };
};
exports.CryptoExchangeRatesApiAxiosParamCreator = CryptoExchangeRatesApiAxiosParamCreator;
/**
 * CryptoExchangeRatesApi - functional programming interface
 * @export
 */
const CryptoExchangeRatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CryptoExchangeRatesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Fetch the current rates for the specified trading pair. The trading pair is defined by a base currency followed by a quote currency. The response contains buy and sell rates denominated in the quote currency. **Exchange rate is an estimate only and is subject to change by the time you submit the actual request.**
         * @summary Get a exchange rate
         * @param {'BTC-USD' | 'ETH-USD' | 'FLOW-USD'} tradingPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRates(tradingPair, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeRates(tradingPair, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        }
    };
};
exports.CryptoExchangeRatesApiFp = CryptoExchangeRatesApiFp;
/**
 * CryptoExchangeRatesApi - factory interface
 * @export
 */
const CryptoExchangeRatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CryptoExchangeRatesApiFp)(configuration);
    return {
        /**
         * Fetch the current rates for the specified trading pair. The trading pair is defined by a base currency followed by a quote currency. The response contains buy and sell rates denominated in the quote currency. **Exchange rate is an estimate only and is subject to change by the time you submit the actual request.**
         * @summary Get a exchange rate
         * @param {'BTC-USD' | 'ETH-USD' | 'FLOW-USD'} tradingPair
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeRates(tradingPair, options) {
            return localVarFp
                .getExchangeRates(tradingPair, options)
                .then((request) => request(axios, basePath));
        }
    };
};
exports.CryptoExchangeRatesApiFactory = CryptoExchangeRatesApiFactory;
/**
 * CryptoExchangeRatesApi - object-oriented interface
 * @export
 * @class CryptoExchangeRatesApi
 * @extends {BaseAPI}
 */
class CryptoExchangeRatesApi extends base_1.BaseAPI {
    /**
     * Fetch the current rates for the specified trading pair. The trading pair is defined by a base currency followed by a quote currency. The response contains buy and sell rates denominated in the quote currency. **Exchange rate is an estimate only and is subject to change by the time you submit the actual request.**
     * @summary Get a exchange rate
     * @param {'BTC-USD' | 'ETH-USD' | 'FLOW-USD'} tradingPair
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CryptoExchangeRatesApi
     */
    getExchangeRates(tradingPair, options) {
        return (0, exports.CryptoExchangeRatesApiFp)(this.configuration)
            .getExchangeRates(tradingPair, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.CryptoExchangeRatesApi = CryptoExchangeRatesApi;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3J5cHRvLWV4Y2hhbmdlLXJhdGVzLWFwaS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9nZW5lcmF0ZWQvYXBpcy9jcnlwdG8tZXhjaGFuZ2UtcmF0ZXMtYXBpLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCOzs7O0dBSUc7Ozs7Ozs7Ozs7Ozs7OztBQUVILGtEQUllO0FBRWYseURBQXlEO0FBQ3pELGFBQWE7QUFDYixzQ0FRbUI7QUFDbkIsYUFBYTtBQUNiLGtDQU1pQjtBQU9qQjs7O0dBR0c7QUFDSSxNQUFNLHVDQUF1QyxHQUFHLFVBQ3JELGFBQTZCO0lBRTdCLE9BQU87UUFDTDs7Ozs7O1dBTUc7UUFDSCxnQkFBZ0IsRUFBRSxDQUNoQixXQUErQyxFQUMvQyxVQUE4QixFQUFFLEVBQ1YsRUFBRTtZQUN4QixtRUFBbUU7WUFDbkUsSUFBQSwwQkFBaUIsRUFBQyxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDbEUsTUFBTSxZQUFZLEdBQUcsbUNBQW1DLENBQUMsT0FBTyxDQUM5RCxJQUFJLGNBQWMsR0FBRyxFQUNyQixrQkFBa0IsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FDeEMsQ0FBQztZQUNGLG9GQUFvRjtZQUNwRixNQUFNLGNBQWMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxZQUFZLEVBQUUsdUJBQWMsQ0FBQyxDQUFDO1lBQzdELElBQUksV0FBVyxDQUFDO1lBQ2hCLElBQUksYUFBYSxFQUFFO2dCQUNqQixXQUFXLEdBQUcsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUN6QztZQUVELE1BQU0sc0JBQXNCLGlDQUMxQixNQUFNLEVBQUUsS0FBSyxJQUNWLFdBQVcsR0FDWCxPQUFPLENBQ1gsQ0FBQztZQUNGLE1BQU0sdUJBQXVCLEdBQUcsRUFBUyxDQUFDO1lBQzFDLE1BQU0sc0JBQXNCLEdBQUcsRUFBUyxDQUFDO1lBRXpDLHFDQUFxQztZQUNyQyxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFBLDhCQUFxQixFQUFDLHVCQUF1QixFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXBFLElBQUEsd0JBQWUsRUFBQyxjQUFjLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztZQUN4RCxJQUFJLHNCQUFzQixHQUN4QixXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQ2hFLHNCQUFzQixDQUFDLE9BQU8saURBQ3pCLHVCQUF1QixHQUN2QixzQkFBc0IsR0FDdEIsT0FBTyxDQUFDLE9BQU8sQ0FDbkIsQ0FBQztZQUVGLE9BQU87Z0JBQ0wsR0FBRyxFQUFFLElBQUEscUJBQVksRUFBQyxjQUFjLENBQUM7Z0JBQ2pDLE9BQU8sRUFBRSxzQkFBc0I7YUFDaEMsQ0FBQztRQUNKLENBQUMsQ0FBQTtLQUNGLENBQUM7QUFDSixDQUFDLENBQUM7QUF2RFcsUUFBQSx1Q0FBdUMsMkNBdURsRDtBQUVGOzs7R0FHRztBQUNJLE1BQU0sd0JBQXdCLEdBQUcsVUFDdEMsYUFBNkI7SUFFN0IsTUFBTSx5QkFBeUIsR0FDN0IsSUFBQSwrQ0FBdUMsRUFBQyxhQUFhLENBQUMsQ0FBQztJQUN6RCxPQUFPO1FBQ0w7Ozs7OztXQU1HO1FBQ0csZ0JBQWdCLENBQ3BCLFdBQStDLEVBQy9DLE9BQTRCOztnQkFPNUIsTUFBTSxpQkFBaUIsR0FDckIsTUFBTSx5QkFBeUIsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ3pFLE9BQU8sSUFBQSw4QkFBcUIsRUFDMUIsaUJBQWlCLEVBQ2pCLGVBQVcsRUFDWCxnQkFBUyxFQUNULGFBQWEsQ0FDZCxDQUFDO1lBQ0osQ0FBQztTQUFBO0tBQ0YsQ0FBQztBQUNKLENBQUMsQ0FBQztBQWhDVyxRQUFBLHdCQUF3Qiw0QkFnQ25DO0FBRUY7OztHQUdHO0FBQ0ksTUFBTSw2QkFBNkIsR0FBRyxVQUMzQyxhQUE2QixFQUM3QixRQUFpQixFQUNqQixLQUFxQjtJQUVyQixNQUFNLFVBQVUsR0FBRyxJQUFBLGdDQUF3QixFQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzNELE9BQU87UUFDTDs7Ozs7O1dBTUc7UUFDSCxnQkFBZ0IsQ0FDZCxXQUErQyxFQUMvQyxPQUFhO1lBRWIsT0FBTyxVQUFVO2lCQUNkLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7aUJBQ3RDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2pELENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBdkJXLFFBQUEsNkJBQTZCLGlDQXVCeEM7QUFFRjs7Ozs7R0FLRztBQUNILE1BQWEsc0JBQXVCLFNBQVEsY0FBTztJQUNqRDs7Ozs7OztPQU9HO0lBQ0ksZ0JBQWdCLENBQ3JCLFdBQStDLEVBQy9DLE9BQTRCO1FBRTVCLE9BQU8sSUFBQSxnQ0FBd0IsRUFBQyxJQUFJLENBQUMsYUFBYSxDQUFDO2FBQ2hELGdCQUFnQixDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUM7YUFDdEMsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztJQUMzRCxDQUFDO0NBQ0Y7QUFqQkQsd0RBaUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuXG5pbXBvcnQgZ2xvYmFsQXhpb3MsIHtcbiAgQXhpb3NQcm9taXNlLFxuICBBeGlvc0luc3RhbmNlLFxuICBBeGlvc1JlcXVlc3RDb25maWdcbn0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL2NvbmZpZ3VyYXRpb25cIjtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHtcbiAgRFVNTVlfQkFTRV9VUkwsXG4gIGFzc2VydFBhcmFtRXhpc3RzLFxuICBzZXRCZWFyZXJBdXRoVG9PYmplY3QsXG4gIHNldFNlYXJjaFBhcmFtcyxcbiAgc2VyaWFsaXplRGF0YUlmTmVlZGVkLFxuICB0b1BhdGhTdHJpbmcsXG4gIGNyZWF0ZVJlcXVlc3RGdW5jdGlvblxufSBmcm9tIFwiLi4vY29tbW9uXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQge1xuICBCQVNFX1BBVEgsXG4gIENPTExFQ1RJT05fRk9STUFUUyxcbiAgUmVxdWVzdEFyZ3MsXG4gIEJhc2VBUEksXG4gIFJlcXVpcmVkRXJyb3Jcbn0gZnJvbSBcIi4uL2Jhc2VcIjtcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IEJhZFJlcXVlc3QgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBHZXRFeGNoYW5nZVJhdGVzUmVzcG9uc2UgfSBmcm9tIFwiLi4vbW9kZWxzXCI7XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgeyBOb3RBdXRob3JpemVkIH0gZnJvbSBcIi4uL21vZGVsc1wiO1xuLyoqXG4gKiBDcnlwdG9FeGNoYW5nZVJhdGVzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuZXhwb3J0IGNvbnN0IENyeXB0b0V4Y2hhbmdlUmF0ZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChcbiAgY29uZmlndXJhdGlvbj86IENvbmZpZ3VyYXRpb25cbikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBjdXJyZW50IHJhdGVzIGZvciB0aGUgc3BlY2lmaWVkIHRyYWRpbmcgcGFpci4gVGhlIHRyYWRpbmcgcGFpciBpcyBkZWZpbmVkIGJ5IGEgYmFzZSBjdXJyZW5jeSBmb2xsb3dlZCBieSBhIHF1b3RlIGN1cnJlbmN5LiBUaGUgcmVzcG9uc2UgY29udGFpbnMgYnV5IGFuZCBzZWxsIHJhdGVzIGRlbm9taW5hdGVkIGluIHRoZSBxdW90ZSBjdXJyZW5jeS4gKipFeGNoYW5nZSByYXRlIGlzIGFuIGVzdGltYXRlIG9ubHkgYW5kIGlzIHN1YmplY3QgdG8gY2hhbmdlIGJ5IHRoZSB0aW1lIHlvdSBzdWJtaXQgdGhlIGFjdHVhbCByZXF1ZXN0LioqXG4gICAgICogQHN1bW1hcnkgR2V0IGEgZXhjaGFuZ2UgcmF0ZVxuICAgICAqIEBwYXJhbSB7J0JUQy1VU0QnIHwgJ0VUSC1VU0QnIHwgJ0ZMT1ctVVNEJ30gdHJhZGluZ1BhaXJcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICovXG4gICAgZ2V0RXhjaGFuZ2VSYXRlczogYXN5bmMgKFxuICAgICAgdHJhZGluZ1BhaXI6IFwiQlRDLVVTRFwiIHwgXCJFVEgtVVNEXCIgfCBcIkZMT1ctVVNEXCIsXG4gICAgICBvcHRpb25zOiBBeGlvc1JlcXVlc3RDb25maWcgPSB7fVxuICAgICk6IFByb21pc2U8UmVxdWVzdEFyZ3M+ID0+IHtcbiAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RyYWRpbmdQYWlyJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgIGFzc2VydFBhcmFtRXhpc3RzKFwiZ2V0RXhjaGFuZ2VSYXRlc1wiLCBcInRyYWRpbmdQYWlyXCIsIHRyYWRpbmdQYWlyKTtcbiAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvZXhjaGFuZ2UvcmF0ZXMve3RyYWRpbmctcGFpcn1gLnJlcGxhY2UoXG4gICAgICAgIGB7JHtcInRyYWRpbmctcGFpclwifX1gLFxuICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRyYWRpbmdQYWlyKSlcbiAgICAgICk7XG4gICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIERVTU1ZX0JBU0VfVVJMKTtcbiAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge30gYXMgYW55O1xuICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9IGFzIGFueTtcblxuICAgICAgLy8gYXV0aGVudGljYXRpb24gYmVhcmVyQXV0aCByZXF1aXJlZFxuICAgICAgLy8gaHR0cCBiZWFyZXIgYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAgICAgIGF3YWl0IHNldEJlYXJlckF1dGhUb09iamVjdChsb2NhbFZhckhlYWRlclBhcmFtZXRlciwgY29uZmlndXJhdGlvbik7XG5cbiAgICAgIHNldFNlYXJjaFBhcmFtcyhsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9XG4gICAgICAgIGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7XG4gICAgICAgIC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLFxuICAgICAgICAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVybDogdG9QYXRoU3RyaW5nKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIENyeXB0b0V4Y2hhbmdlUmF0ZXNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgQ3J5cHRvRXhjaGFuZ2VSYXRlc0FwaUZwID0gZnVuY3Rpb24gKFxuICBjb25maWd1cmF0aW9uPzogQ29uZmlndXJhdGlvblxuKSB7XG4gIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPVxuICAgIENyeXB0b0V4Y2hhbmdlUmF0ZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcihjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgY3VycmVudCByYXRlcyBmb3IgdGhlIHNwZWNpZmllZCB0cmFkaW5nIHBhaXIuIFRoZSB0cmFkaW5nIHBhaXIgaXMgZGVmaW5lZCBieSBhIGJhc2UgY3VycmVuY3kgZm9sbG93ZWQgYnkgYSBxdW90ZSBjdXJyZW5jeS4gVGhlIHJlc3BvbnNlIGNvbnRhaW5zIGJ1eSBhbmQgc2VsbCByYXRlcyBkZW5vbWluYXRlZCBpbiB0aGUgcXVvdGUgY3VycmVuY3kuICoqRXhjaGFuZ2UgcmF0ZSBpcyBhbiBlc3RpbWF0ZSBvbmx5IGFuZCBpcyBzdWJqZWN0IHRvIGNoYW5nZSBieSB0aGUgdGltZSB5b3Ugc3VibWl0IHRoZSBhY3R1YWwgcmVxdWVzdC4qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIGV4Y2hhbmdlIHJhdGVcbiAgICAgKiBAcGFyYW0geydCVEMtVVNEJyB8ICdFVEgtVVNEJyB8ICdGTE9XLVVTRCd9IHRyYWRpbmdQYWlyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIGdldEV4Y2hhbmdlUmF0ZXMoXG4gICAgICB0cmFkaW5nUGFpcjogXCJCVEMtVVNEXCIgfCBcIkVUSC1VU0RcIiB8IFwiRkxPVy1VU0RcIixcbiAgICAgIG9wdGlvbnM/OiBBeGlvc1JlcXVlc3RDb25maWdcbiAgICApOiBQcm9taXNlPFxuICAgICAgKFxuICAgICAgICBheGlvcz86IEF4aW9zSW5zdGFuY2UsXG4gICAgICAgIGJhc2VQYXRoPzogc3RyaW5nXG4gICAgICApID0+IEF4aW9zUHJvbWlzZTxHZXRFeGNoYW5nZVJhdGVzUmVzcG9uc2U+XG4gICAgPiB7XG4gICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9XG4gICAgICAgIGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RXhjaGFuZ2VSYXRlcyh0cmFkaW5nUGFpciwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKFxuICAgICAgICBsb2NhbFZhckF4aW9zQXJncyxcbiAgICAgICAgZ2xvYmFsQXhpb3MsXG4gICAgICAgIEJBU0VfUEFUSCxcbiAgICAgICAgY29uZmlndXJhdGlvblxuICAgICAgKTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIENyeXB0b0V4Y2hhbmdlUmF0ZXNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5leHBvcnQgY29uc3QgQ3J5cHRvRXhjaGFuZ2VSYXRlc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoXG4gIGNvbmZpZ3VyYXRpb24/OiBDb25maWd1cmF0aW9uLFxuICBiYXNlUGF0aD86IHN0cmluZyxcbiAgYXhpb3M/OiBBeGlvc0luc3RhbmNlXG4pIHtcbiAgY29uc3QgbG9jYWxWYXJGcCA9IENyeXB0b0V4Y2hhbmdlUmF0ZXNBcGlGcChjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgY3VycmVudCByYXRlcyBmb3IgdGhlIHNwZWNpZmllZCB0cmFkaW5nIHBhaXIuIFRoZSB0cmFkaW5nIHBhaXIgaXMgZGVmaW5lZCBieSBhIGJhc2UgY3VycmVuY3kgZm9sbG93ZWQgYnkgYSBxdW90ZSBjdXJyZW5jeS4gVGhlIHJlc3BvbnNlIGNvbnRhaW5zIGJ1eSBhbmQgc2VsbCByYXRlcyBkZW5vbWluYXRlZCBpbiB0aGUgcXVvdGUgY3VycmVuY3kuICoqRXhjaGFuZ2UgcmF0ZSBpcyBhbiBlc3RpbWF0ZSBvbmx5IGFuZCBpcyBzdWJqZWN0IHRvIGNoYW5nZSBieSB0aGUgdGltZSB5b3Ugc3VibWl0IHRoZSBhY3R1YWwgcmVxdWVzdC4qKlxuICAgICAqIEBzdW1tYXJ5IEdldCBhIGV4Y2hhbmdlIHJhdGVcbiAgICAgKiBAcGFyYW0geydCVEMtVVNEJyB8ICdFVEgtVVNEJyB8ICdGTE9XLVVTRCd9IHRyYWRpbmdQYWlyXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqL1xuICAgIGdldEV4Y2hhbmdlUmF0ZXMoXG4gICAgICB0cmFkaW5nUGFpcjogXCJCVEMtVVNEXCIgfCBcIkVUSC1VU0RcIiB8IFwiRkxPVy1VU0RcIixcbiAgICAgIG9wdGlvbnM/OiBhbnlcbiAgICApOiBBeGlvc1Byb21pc2U8R2V0RXhjaGFuZ2VSYXRlc1Jlc3BvbnNlPiB7XG4gICAgICByZXR1cm4gbG9jYWxWYXJGcFxuICAgICAgICAuZ2V0RXhjaGFuZ2VSYXRlcyh0cmFkaW5nUGFpciwgb3B0aW9ucylcbiAgICAgICAgLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBDcnlwdG9FeGNoYW5nZVJhdGVzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIENyeXB0b0V4Y2hhbmdlUmF0ZXNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5leHBvcnQgY2xhc3MgQ3J5cHRvRXhjaGFuZ2VSYXRlc0FwaSBleHRlbmRzIEJhc2VBUEkge1xuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgcmF0ZXMgZm9yIHRoZSBzcGVjaWZpZWQgdHJhZGluZyBwYWlyLiBUaGUgdHJhZGluZyBwYWlyIGlzIGRlZmluZWQgYnkgYSBiYXNlIGN1cnJlbmN5IGZvbGxvd2VkIGJ5IGEgcXVvdGUgY3VycmVuY3kuIFRoZSByZXNwb25zZSBjb250YWlucyBidXkgYW5kIHNlbGwgcmF0ZXMgZGVub21pbmF0ZWQgaW4gdGhlIHF1b3RlIGN1cnJlbmN5LiAqKkV4Y2hhbmdlIHJhdGUgaXMgYW4gZXN0aW1hdGUgb25seSBhbmQgaXMgc3ViamVjdCB0byBjaGFuZ2UgYnkgdGhlIHRpbWUgeW91IHN1Ym1pdCB0aGUgYWN0dWFsIHJlcXVlc3QuKipcbiAgICogQHN1bW1hcnkgR2V0IGEgZXhjaGFuZ2UgcmF0ZVxuICAgKiBAcGFyYW0geydCVEMtVVNEJyB8ICdFVEgtVVNEJyB8ICdGTE9XLVVTRCd9IHRyYWRpbmdQYWlyXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAqIEBtZW1iZXJvZiBDcnlwdG9FeGNoYW5nZVJhdGVzQXBpXG4gICAqL1xuICBwdWJsaWMgZ2V0RXhjaGFuZ2VSYXRlcyhcbiAgICB0cmFkaW5nUGFpcjogXCJCVEMtVVNEXCIgfCBcIkVUSC1VU0RcIiB8IFwiRkxPVy1VU0RcIixcbiAgICBvcHRpb25zPzogQXhpb3NSZXF1ZXN0Q29uZmlnXG4gICkge1xuICAgIHJldHVybiBDcnlwdG9FeGNoYW5nZVJhdGVzQXBpRnAodGhpcy5jb25maWd1cmF0aW9uKVxuICAgICAgLmdldEV4Y2hhbmdlUmF0ZXModHJhZGluZ1BhaXIsIG9wdGlvbnMpXG4gICAgICAudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gIH1cbn1cbiJdfQ==